#BlueJ class context
comment0.target=Deflater
comment0.text=\r\n\ This\ class\ provides\ support\ for\ general\ purpose\ compression\ using\ the\r\n\ popular\ ZLIB\ compression\ library.\ The\ ZLIB\ compression\ library\ was\r\n\ initially\ developed\ as\ part\ of\ the\ PNG\ graphics\ standard\ and\ is\ not\r\n\ protected\ by\ patents.\ It\ is\ fully\ described\ in\ the\ specifications\ at\r\n\ the\ <a\ href\="package-summary.html\#package_description">java.util.zip\r\n\ package\ description</a>.\r\n\r\n\ <p>The\ following\ code\ fragment\ demonstrates\ a\ trivial\ compression\r\n\ and\ decompression\ of\ a\ string\ using\ <tt>Deflater</tt>\ and\r\n\ <tt>Inflater</tt>.\r\n\r\n\ <blockquote><pre>\r\n\ try\ {\r\n\ \ \ \ \ //\ Encode\ a\ String\ into\ bytes\r\n\ \ \ \ \ String\ inputString\ \=\ "blahblahblah";\r\n\ \ \ \ \ byte[]\ input\ \=\ inputString.getBytes("UTF-8");\r\n\r\n\ \ \ \ \ //\ Compress\ the\ bytes\r\n\ \ \ \ \ byte[]\ output\ \=\ new\ byte[100];\r\n\ \ \ \ \ Deflater\ compresser\ \=\ new\ Deflater();\r\n\ \ \ \ \ compresser.setInput(input);\r\n\ \ \ \ \ compresser.finish();\r\n\ \ \ \ \ int\ compressedDataLength\ \=\ compresser.deflate(output);\r\n\ \ \ \ \ compresser.end();\r\n\r\n\ \ \ \ \ //\ Decompress\ the\ bytes\r\n\ \ \ \ \ Inflater\ decompresser\ \=\ new\ Inflater();\r\n\ \ \ \ \ decompresser.setInput(output,\ 0,\ compressedDataLength);\r\n\ \ \ \ \ byte[]\ result\ \=\ new\ byte[100];\r\n\ \ \ \ \ int\ resultLength\ \=\ decompresser.inflate(result);\r\n\ \ \ \ \ decompresser.end();\r\n\r\n\ \ \ \ \ //\ Decode\ the\ bytes\ into\ a\ String\r\n\ \ \ \ \ String\ outputString\ \=\ new\ String(result,\ 0,\ resultLength,\ "UTF-8");\r\n\ }\ catch(java.io.UnsupportedEncodingException\ ex)\ {\r\n\ \ \ \ \ //\ handle\r\n\ }\ catch\ (java.util.zip.DataFormatException\ ex)\ {\r\n\ \ \ \ \ //\ handle\r\n\ }\r\n\ </pre></blockquote>\r\n\r\n\ @see\ \ \ \ \ \ \ \ \ Inflater\r\n\ @author\ \ \ \ \ \ David\ Connelly\r\n
comment1.params=level\ nowrap
comment1.target=Deflater(int,\ boolean)
comment1.text=\r\n\ Creates\ a\ new\ compressor\ using\ the\ specified\ compression\ level.\r\n\ If\ 'nowrap'\ is\ true\ then\ the\ ZLIB\ header\ and\ checksum\ fields\ will\r\n\ not\ be\ used\ in\ order\ to\ support\ the\ compression\ format\ used\ in\r\n\ both\ GZIP\ and\ PKZIP.\r\n\ @param\ level\ the\ compression\ level\ (0-9)\r\n\ @param\ nowrap\ if\ true\ then\ use\ GZIP\ compatible\ compression\r\n
comment10.params=
comment10.target=boolean\ needsInput()
comment10.text=\r\n\ Returns\ true\ if\ the\ input\ data\ buffer\ is\ empty\ and\ setInput()\r\n\ should\ be\ called\ in\ order\ to\ provide\ more\ input.\r\n\ @return\ true\ if\ the\ input\ data\ buffer\ is\ empty\ and\ setInput()\r\n\ should\ be\ called\ in\ order\ to\ provide\ more\ input\r\n
comment11.params=
comment11.target=void\ finish()
comment11.text=\r\n\ When\ called,\ indicates\ that\ compression\ should\ end\ with\ the\ current\r\n\ contents\ of\ the\ input\ buffer.\r\n
comment12.params=
comment12.target=boolean\ finished()
comment12.text=\r\n\ Returns\ true\ if\ the\ end\ of\ the\ compressed\ data\ output\ stream\ has\r\n\ been\ reached.\r\n\ @return\ true\ if\ the\ end\ of\ the\ compressed\ data\ output\ stream\ has\r\n\ been\ reached\r\n
comment13.params=b\ off\ len
comment13.target=int\ deflate(byte[],\ int,\ int)
comment13.text=\r\n\ Compresses\ the\ input\ data\ and\ fills\ specified\ buffer\ with\ compressed\r\n\ data.\ Returns\ actual\ number\ of\ bytes\ of\ compressed\ data.\ A\ return\ value\r\n\ of\ 0\ indicates\ that\ {@link\ \#needsInput()\ needsInput}\ should\ be\ called\r\n\ in\ order\ to\ determine\ if\ more\ input\ data\ is\ required.\r\n\r\n\ <p>This\ method\ uses\ {@link\ \#NO_FLUSH}\ as\ its\ compression\ flush\ mode.\r\n\ An\ invocation\ of\ this\ method\ of\ the\ form\ {@code\ deflater.deflate(b,\ off,\ len)}\r\n\ yields\ the\ same\ result\ as\ the\ invocation\ of\r\n\ {@code\ deflater.deflate(b,\ off,\ len,\ Deflater.NO_FLUSH)}.\r\n\r\n\ @param\ b\ the\ buffer\ for\ the\ compressed\ data\r\n\ @param\ off\ the\ start\ offset\ of\ the\ data\r\n\ @param\ len\ the\ maximum\ number\ of\ bytes\ of\ compressed\ data\r\n\ @return\ the\ actual\ number\ of\ bytes\ of\ compressed\ data\ written\ to\ the\r\n\ \ \ \ \ \ \ \ \ output\ buffer\r\n
comment14.params=b
comment14.target=int\ deflate(byte[])
comment14.text=\r\n\ Compresses\ the\ input\ data\ and\ fills\ specified\ buffer\ with\ compressed\r\n\ data.\ Returns\ actual\ number\ of\ bytes\ of\ compressed\ data.\ A\ return\ value\r\n\ of\ 0\ indicates\ that\ {@link\ \#needsInput()\ needsInput}\ should\ be\ called\r\n\ in\ order\ to\ determine\ if\ more\ input\ data\ is\ required.\r\n\r\n\ <p>This\ method\ uses\ {@link\ \#NO_FLUSH}\ as\ its\ compression\ flush\ mode.\r\n\ An\ invocation\ of\ this\ method\ of\ the\ form\ {@code\ deflater.deflate(b)}\r\n\ yields\ the\ same\ result\ as\ the\ invocation\ of\r\n\ {@code\ deflater.deflate(b,\ 0,\ b.length,\ Deflater.NO_FLUSH)}.\r\n\r\n\ @param\ b\ the\ buffer\ for\ the\ compressed\ data\r\n\ @return\ the\ actual\ number\ of\ bytes\ of\ compressed\ data\ written\ to\ the\r\n\ \ \ \ \ \ \ \ \ output\ buffer\r\n
comment15.params=b\ off\ len\ flush
comment15.target=int\ deflate(byte[],\ int,\ int,\ int)
comment15.text=\r\n\ Compresses\ the\ input\ data\ and\ fills\ the\ specified\ buffer\ with\ compressed\r\n\ data.\ Returns\ actual\ number\ of\ bytes\ of\ data\ compressed.\r\n\r\n\ <p>Compression\ flush\ mode\ is\ one\ of\ the\ following\ three\ modes\:\r\n\r\n\ <ul>\r\n\ <li>{@link\ \#NO_FLUSH}\:\ allows\ the\ deflater\ to\ decide\ how\ much\ data\r\n\ to\ accumulate,\ before\ producing\ output,\ in\ order\ to\ achieve\ the\ best\r\n\ compression\ (should\ be\ used\ in\ normal\ use\ scenario).\ A\ return\ value\r\n\ of\ 0\ in\ this\ flush\ mode\ indicates\ that\ {@link\ \#needsInput()}\ should\r\n\ be\ called\ in\ order\ to\ determine\ if\ more\ input\ data\ is\ required.\r\n\r\n\ <li>{@link\ \#SYNC_FLUSH}\:\ all\ pending\ output\ in\ the\ deflater\ is\ flushed,\r\n\ to\ the\ specified\ output\ buffer,\ so\ that\ an\ inflater\ that\ works\ on\r\n\ compressed\ data\ can\ get\ all\ input\ data\ available\ so\ far\ (In\ particular\r\n\ the\ {@link\ \#needsInput()}\ returns\ {@code\ true}\ after\ this\ invocation\r\n\ if\ enough\ output\ space\ is\ provided).\ Flushing\ with\ {@link\ \#SYNC_FLUSH}\r\n\ may\ degrade\ compression\ for\ some\ compression\ algorithms\ and\ so\ it\r\n\ should\ be\ used\ only\ when\ necessary.\r\n\r\n\ <li>{@link\ \#FULL_FLUSH}\:\ all\ pending\ output\ is\ flushed\ out\ as\ with\r\n\ {@link\ \#SYNC_FLUSH}.\ The\ compression\ state\ is\ reset\ so\ that\ the\ inflater\r\n\ that\ works\ on\ the\ compressed\ output\ data\ can\ restart\ from\ this\ point\r\n\ if\ previous\ compressed\ data\ has\ been\ damaged\ or\ if\ random\ access\ is\r\n\ desired.\ Using\ {@link\ \#FULL_FLUSH}\ too\ often\ can\ seriously\ degrade\r\n\ compression.\r\n\ </ul>\r\n\r\n\ <p>In\ the\ case\ of\ {@link\ \#FULL_FLUSH}\ or\ {@link\ \#SYNC_FLUSH},\ if\r\n\ the\ return\ value\ is\ {@code\ len},\ the\ space\ available\ in\ output\r\n\ buffer\ {@code\ b},\ this\ method\ should\ be\ invoked\ again\ with\ the\ same\r\n\ {@code\ flush}\ parameter\ and\ more\ output\ space.\r\n\r\n\ @param\ b\ the\ buffer\ for\ the\ compressed\ data\r\n\ @param\ off\ the\ start\ offset\ of\ the\ data\r\n\ @param\ len\ the\ maximum\ number\ of\ bytes\ of\ compressed\ data\r\n\ @param\ flush\ the\ compression\ flush\ mode\r\n\ @return\ the\ actual\ number\ of\ bytes\ of\ compressed\ data\ written\ to\r\n\ \ \ \ \ \ \ \ \ the\ output\ buffer\r\n\r\n\ @throws\ IllegalArgumentException\ if\ the\ flush\ mode\ is\ invalid\r\n\ @since\ 1.7\r\n
comment16.params=
comment16.target=int\ getAdler()
comment16.text=\r\n\ Returns\ the\ ADLER-32\ value\ of\ the\ uncompressed\ data.\r\n\ @return\ the\ ADLER-32\ value\ of\ the\ uncompressed\ data\r\n
comment17.params=
comment17.target=int\ getTotalIn()
comment17.text=\r\n\ Returns\ the\ total\ number\ of\ uncompressed\ bytes\ input\ so\ far.\r\n\r\n\ <p>Since\ the\ number\ of\ bytes\ may\ be\ greater\ than\r\n\ Integer.MAX_VALUE,\ the\ {@link\ \#getBytesRead()}\ method\ is\ now\r\n\ the\ preferred\ means\ of\ obtaining\ this\ information.</p>\r\n\r\n\ @return\ the\ total\ number\ of\ uncompressed\ bytes\ input\ so\ far\r\n
comment18.params=
comment18.target=long\ getBytesRead()
comment18.text=\r\n\ Returns\ the\ total\ number\ of\ uncompressed\ bytes\ input\ so\ far.</p>\r\n\r\n\ @return\ the\ total\ (non-negative)\ number\ of\ uncompressed\ bytes\ input\ so\ far\r\n\ @since\ 1.5\r\n
comment19.params=
comment19.target=int\ getTotalOut()
comment19.text=\r\n\ Returns\ the\ total\ number\ of\ compressed\ bytes\ output\ so\ far.\r\n\r\n\ <p>Since\ the\ number\ of\ bytes\ may\ be\ greater\ than\r\n\ Integer.MAX_VALUE,\ the\ {@link\ \#getBytesWritten()}\ method\ is\ now\r\n\ the\ preferred\ means\ of\ obtaining\ this\ information.</p>\r\n\r\n\ @return\ the\ total\ number\ of\ compressed\ bytes\ output\ so\ far\r\n
comment2.params=level
comment2.target=Deflater(int)
comment2.text=\r\n\ Creates\ a\ new\ compressor\ using\ the\ specified\ compression\ level.\r\n\ Compressed\ data\ will\ be\ generated\ in\ ZLIB\ format.\r\n\ @param\ level\ the\ compression\ level\ (0-9)\r\n
comment20.params=
comment20.target=long\ getBytesWritten()
comment20.text=\r\n\ Returns\ the\ total\ number\ of\ compressed\ bytes\ output\ so\ far.</p>\r\n\r\n\ @return\ the\ total\ (non-negative)\ number\ of\ compressed\ bytes\ output\ so\ far\r\n\ @since\ 1.5\r\n
comment21.params=
comment21.target=void\ reset()
comment21.text=\r\n\ Resets\ deflater\ so\ that\ a\ new\ set\ of\ input\ data\ can\ be\ processed.\r\n\ Keeps\ current\ compression\ level\ and\ strategy\ settings.\r\n
comment22.params=
comment22.target=void\ end()
comment22.text=\r\n\ Closes\ the\ compressor\ and\ discards\ any\ unprocessed\ input.\r\n\ This\ method\ should\ be\ called\ when\ the\ compressor\ is\ no\ longer\r\n\ being\ used,\ but\ will\ also\ be\ called\ automatically\ by\ the\r\n\ finalize()\ method.\ Once\ this\ method\ is\ called,\ the\ behavior\r\n\ of\ the\ Deflater\ object\ is\ undefined.\r\n
comment23.params=
comment23.target=void\ finalize()
comment23.text=\r\n\ Closes\ the\ compressor\ when\ garbage\ is\ collected.\r\n
comment24.params=
comment24.target=void\ ensureOpen()
comment25.params=
comment25.target=void\ initIDs()
comment26.params=level\ strategy\ nowrap
comment26.target=long\ init(int,\ int,\ boolean)
comment27.params=addr\ b\ off\ len
comment27.target=void\ setDictionary(long,\ byte[],\ int,\ int)
comment28.params=addr\ b\ off\ len\ flush
comment28.target=int\ deflateBytes(long,\ byte[],\ int,\ int,\ int)
comment29.params=addr
comment29.target=int\ getAdler(long)
comment3.params=
comment3.target=Deflater()
comment3.text=\r\n\ Creates\ a\ new\ compressor\ with\ the\ default\ compression\ level.\r\n\ Compressed\ data\ will\ be\ generated\ in\ ZLIB\ format.\r\n
comment30.params=addr
comment30.target=void\ reset(long)
comment31.params=addr
comment31.target=void\ end(long)
comment4.params=b\ off\ len
comment4.target=void\ setInput(byte[],\ int,\ int)
comment4.text=\r\n\ Sets\ input\ data\ for\ compression.\ This\ should\ be\ called\ whenever\r\n\ needsInput()\ returns\ true\ indicating\ that\ more\ input\ data\ is\ required.\r\n\ @param\ b\ the\ input\ data\ bytes\r\n\ @param\ off\ the\ start\ offset\ of\ the\ data\r\n\ @param\ len\ the\ length\ of\ the\ data\r\n\ @see\ Deflater\#needsInput\r\n
comment5.params=b
comment5.target=void\ setInput(byte[])
comment5.text=\r\n\ Sets\ input\ data\ for\ compression.\ This\ should\ be\ called\ whenever\r\n\ needsInput()\ returns\ true\ indicating\ that\ more\ input\ data\ is\ required.\r\n\ @param\ b\ the\ input\ data\ bytes\r\n\ @see\ Deflater\#needsInput\r\n
comment6.params=b\ off\ len
comment6.target=void\ setDictionary(byte[],\ int,\ int)
comment6.text=\r\n\ Sets\ preset\ dictionary\ for\ compression.\ A\ preset\ dictionary\ is\ used\r\n\ when\ the\ history\ buffer\ can\ be\ predetermined.\ When\ the\ data\ is\ later\r\n\ uncompressed\ with\ Inflater.inflate(),\ Inflater.getAdler()\ can\ be\ called\r\n\ in\ order\ to\ get\ the\ Adler-32\ value\ of\ the\ dictionary\ required\ for\r\n\ decompression.\r\n\ @param\ b\ the\ dictionary\ data\ bytes\r\n\ @param\ off\ the\ start\ offset\ of\ the\ data\r\n\ @param\ len\ the\ length\ of\ the\ data\r\n\ @see\ Inflater\#inflate\r\n\ @see\ Inflater\#getAdler\r\n
comment7.params=b
comment7.target=void\ setDictionary(byte[])
comment7.text=\r\n\ Sets\ preset\ dictionary\ for\ compression.\ A\ preset\ dictionary\ is\ used\r\n\ when\ the\ history\ buffer\ can\ be\ predetermined.\ When\ the\ data\ is\ later\r\n\ uncompressed\ with\ Inflater.inflate(),\ Inflater.getAdler()\ can\ be\ called\r\n\ in\ order\ to\ get\ the\ Adler-32\ value\ of\ the\ dictionary\ required\ for\r\n\ decompression.\r\n\ @param\ b\ the\ dictionary\ data\ bytes\r\n\ @see\ Inflater\#inflate\r\n\ @see\ Inflater\#getAdler\r\n
comment8.params=strategy
comment8.target=void\ setStrategy(int)
comment8.text=\r\n\ Sets\ the\ compression\ strategy\ to\ the\ specified\ value.\r\n\ @param\ strategy\ the\ new\ compression\ strategy\r\n\ @exception\ IllegalArgumentException\ if\ the\ compression\ strategy\ is\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ invalid\r\n
comment9.params=level
comment9.target=void\ setLevel(int)
comment9.text=\r\n\ Sets\ the\ current\ compression\ level\ to\ the\ specified\ value.\r\n\ @param\ level\ the\ new\ compression\ level\ (0-9)\r\n\ @exception\ IllegalArgumentException\ if\ the\ compression\ level\ is\ invalid\r\n
numComments=32
