#BlueJ class context
comment0.target=ScheduledThreadPoolExecutor
comment0.text=\r\n\ A\ {@link\ ThreadPoolExecutor}\ that\ can\ additionally\ schedule\r\n\ commands\ to\ run\ after\ a\ given\ delay,\ or\ to\ execute\r\n\ periodically.\ This\ class\ is\ preferable\ to\ {@link\ java.util.Timer}\r\n\ when\ multiple\ worker\ threads\ are\ needed,\ or\ when\ the\ additional\r\n\ flexibility\ or\ capabilities\ of\ {@link\ ThreadPoolExecutor}\ (which\r\n\ this\ class\ extends)\ are\ required.\r\n\r\n\ <p>Delayed\ tasks\ execute\ no\ sooner\ than\ they\ are\ enabled,\ but\r\n\ without\ any\ real-time\ guarantees\ about\ when,\ after\ they\ are\r\n\ enabled,\ they\ will\ commence.\ Tasks\ scheduled\ for\ exactly\ the\ same\r\n\ execution\ time\ are\ enabled\ in\ first-in-first-out\ (FIFO)\ order\ of\r\n\ submission.\r\n\r\n\ <p>When\ a\ submitted\ task\ is\ cancelled\ before\ it\ is\ run,\ execution\r\n\ is\ suppressed.\ By\ default,\ such\ a\ cancelled\ task\ is\ not\r\n\ automatically\ removed\ from\ the\ work\ queue\ until\ its\ delay\r\n\ elapses.\ While\ this\ enables\ further\ inspection\ and\ monitoring,\ it\r\n\ may\ also\ cause\ unbounded\ retention\ of\ cancelled\ tasks.\ To\ avoid\r\n\ this,\ set\ {@link\ \#setRemoveOnCancelPolicy}\ to\ {@code\ true},\ which\r\n\ causes\ tasks\ to\ be\ immediately\ removed\ from\ the\ work\ queue\ at\r\n\ time\ of\ cancellation.\r\n\r\n\ <p>Successive\ executions\ of\ a\ task\ scheduled\ via\r\n\ {@code\ scheduleAtFixedRate}\ or\r\n\ {@code\ scheduleWithFixedDelay}\ do\ not\ overlap.\ While\ different\r\n\ executions\ may\ be\ performed\ by\ different\ threads,\ the\ effects\ of\r\n\ prior\ executions\ <a\r\n\ href\="package-summary.html\#MemoryVisibility"><i>happen-before</i></a>\r\n\ those\ of\ subsequent\ ones.\r\n\r\n\ <p>While\ this\ class\ inherits\ from\ {@link\ ThreadPoolExecutor},\ a\ few\r\n\ of\ the\ inherited\ tuning\ methods\ are\ not\ useful\ for\ it.\ In\r\n\ particular,\ because\ it\ acts\ as\ a\ fixed-sized\ pool\ using\r\n\ {@code\ corePoolSize}\ threads\ and\ an\ unbounded\ queue,\ adjustments\r\n\ to\ {@code\ maximumPoolSize}\ have\ no\ useful\ effect.\ Additionally,\ it\r\n\ is\ almost\ never\ a\ good\ idea\ to\ set\ {@code\ corePoolSize}\ to\ zero\ or\r\n\ use\ {@code\ allowCoreThreadTimeOut}\ because\ this\ may\ leave\ the\ pool\r\n\ without\ threads\ to\ handle\ tasks\ once\ they\ become\ eligible\ to\ run.\r\n\r\n\ <p><b>Extension\ notes\:</b>\ This\ class\ overrides\ the\r\n\ {@link\ ThreadPoolExecutor\#execute\ execute}\ and\r\n\ {@link\ AbstractExecutorService\#submit(Runnable)\ submit}\r\n\ methods\ to\ generate\ internal\ {@link\ ScheduledFuture}\ objects\ to\r\n\ control\ per-task\ delays\ and\ scheduling.\ \ To\ preserve\r\n\ functionality,\ any\ further\ overrides\ of\ these\ methods\ in\r\n\ subclasses\ must\ invoke\ superclass\ versions,\ which\ effectively\r\n\ disables\ additional\ task\ customization.\ \ However,\ this\ class\r\n\ provides\ alternative\ protected\ extension\ method\r\n\ {@code\ decorateTask}\ (one\ version\ each\ for\ {@code\ Runnable}\ and\r\n\ {@code\ Callable})\ that\ can\ be\ used\ to\ customize\ the\ concrete\ task\r\n\ types\ used\ to\ execute\ commands\ entered\ via\ {@code\ execute},\r\n\ {@code\ submit},\ {@code\ schedule},\ {@code\ scheduleAtFixedRate},\r\n\ and\ {@code\ scheduleWithFixedDelay}.\ \ By\ default,\ a\r\n\ {@code\ ScheduledThreadPoolExecutor}\ uses\ a\ task\ type\ extending\r\n\ {@link\ FutureTask}.\ However,\ this\ may\ be\ modified\ or\ replaced\ using\r\n\ subclasses\ of\ the\ form\:\r\n\r\n\ \ <pre>\ {@code\r\n\ public\ class\ CustomScheduledExecutor\ extends\ ScheduledThreadPoolExecutor\ {\r\n\r\n\ \ \ static\ class\ CustomTask<V>\ implements\ RunnableScheduledFuture<V>\ {\ ...\ }\r\n\r\n\ \ \ protected\ <V>\ RunnableScheduledFuture<V>\ decorateTask(\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Runnable\ r,\ RunnableScheduledFuture<V>\ task)\ {\r\n\ \ \ \ \ \ \ return\ new\ CustomTask<V>(r,\ task);\r\n\ \ \ }\r\n\r\n\ \ \ protected\ <V>\ RunnableScheduledFuture<V>\ decorateTask(\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Callable<V>\ c,\ RunnableScheduledFuture<V>\ task)\ {\r\n\ \ \ \ \ \ \ return\ new\ CustomTask<V>(c,\ task);\r\n\ \ \ }\r\n\ \ \ //\ ...\ add\ constructors,\ etc.\r\n\ }}</pre>\r\n\r\n\ @since\ 1.5\r\n\ @author\ Doug\ Lea\r\n
comment1.params=
comment1.target=long\ now()
comment1.text=\r\n\ Returns\ current\ nanosecond\ time.\r\n
comment10.params=corePoolSize\ handler
comment10.target=ScheduledThreadPoolExecutor(int,\ RejectedExecutionHandler)
comment10.text=\r\n\ Creates\ a\ new\ ScheduledThreadPoolExecutor\ with\ the\ given\r\n\ initial\ parameters.\r\n\r\n\ @param\ corePoolSize\ the\ number\ of\ threads\ to\ keep\ in\ the\ pool,\ even\r\n\ \ \ \ \ \ \ \ if\ they\ are\ idle,\ unless\ {@code\ allowCoreThreadTimeOut}\ is\ set\r\n\ @param\ handler\ the\ handler\ to\ use\ when\ execution\ is\ blocked\r\n\ \ \ \ \ \ \ \ because\ the\ thread\ bounds\ and\ queue\ capacities\ are\ reached\r\n\ @throws\ IllegalArgumentException\ if\ {@code\ corePoolSize\ <\ 0}\r\n\ @throws\ NullPointerException\ if\ {@code\ handler}\ is\ null\r\n
comment11.params=corePoolSize\ threadFactory\ handler
comment11.target=ScheduledThreadPoolExecutor(int,\ ThreadFactory,\ RejectedExecutionHandler)
comment11.text=\r\n\ Creates\ a\ new\ ScheduledThreadPoolExecutor\ with\ the\ given\r\n\ initial\ parameters.\r\n\r\n\ @param\ corePoolSize\ the\ number\ of\ threads\ to\ keep\ in\ the\ pool,\ even\r\n\ \ \ \ \ \ \ \ if\ they\ are\ idle,\ unless\ {@code\ allowCoreThreadTimeOut}\ is\ set\r\n\ @param\ threadFactory\ the\ factory\ to\ use\ when\ the\ executor\r\n\ \ \ \ \ \ \ \ creates\ a\ new\ thread\r\n\ @param\ handler\ the\ handler\ to\ use\ when\ execution\ is\ blocked\r\n\ \ \ \ \ \ \ \ because\ the\ thread\ bounds\ and\ queue\ capacities\ are\ reached\r\n\ @throws\ IllegalArgumentException\ if\ {@code\ corePoolSize\ <\ 0}\r\n\ @throws\ NullPointerException\ if\ {@code\ threadFactory}\ or\r\n\ \ \ \ \ \ \ \ \ {@code\ handler}\ is\ null\r\n
comment12.params=delay\ unit
comment12.target=long\ triggerTime(long,\ TimeUnit)
comment12.text=\r\n\ Returns\ the\ trigger\ time\ of\ a\ delayed\ action.\r\n
comment13.params=delay
comment13.target=long\ triggerTime(long)
comment13.text=\r\n\ Returns\ the\ trigger\ time\ of\ a\ delayed\ action.\r\n
comment14.params=delay
comment14.target=long\ overflowFree(long)
comment14.text=\r\n\ Constrains\ the\ values\ of\ all\ delays\ in\ the\ queue\ to\ be\ within\r\n\ Long.MAX_VALUE\ of\ each\ other,\ to\ avoid\ overflow\ in\ compareTo.\r\n\ This\ may\ occur\ if\ a\ task\ is\ eligible\ to\ be\ dequeued,\ but\ has\r\n\ not\ yet\ been,\ while\ some\ other\ task\ is\ added\ with\ a\ delay\ of\r\n\ Long.MAX_VALUE.\r\n
comment15.params=command\ delay\ unit
comment15.target=ScheduledFuture\ schedule(java.lang.Runnable,\ long,\ TimeUnit)
comment15.text=\r\n\ @throws\ RejectedExecutionException\ {@inheritDoc}\r\n\ @throws\ NullPointerException\ \ \ \ \ \ \ {@inheritDoc}\r\n
comment16.params=callable\ delay\ unit
comment16.target=ScheduledFuture\ schedule(Callable,\ long,\ TimeUnit)
comment16.text=\r\n\ @throws\ RejectedExecutionException\ {@inheritDoc}\r\n\ @throws\ NullPointerException\ \ \ \ \ \ \ {@inheritDoc}\r\n
comment17.params=command\ initialDelay\ period\ unit
comment17.target=ScheduledFuture\ scheduleAtFixedRate(java.lang.Runnable,\ long,\ long,\ TimeUnit)
comment17.text=\r\n\ @throws\ RejectedExecutionException\ {@inheritDoc}\r\n\ @throws\ NullPointerException\ \ \ \ \ \ \ {@inheritDoc}\r\n\ @throws\ IllegalArgumentException\ \ \ {@inheritDoc}\r\n
comment18.params=command\ initialDelay\ delay\ unit
comment18.target=ScheduledFuture\ scheduleWithFixedDelay(java.lang.Runnable,\ long,\ long,\ TimeUnit)
comment18.text=\r\n\ @throws\ RejectedExecutionException\ {@inheritDoc}\r\n\ @throws\ NullPointerException\ \ \ \ \ \ \ {@inheritDoc}\r\n\ @throws\ IllegalArgumentException\ \ \ {@inheritDoc}\r\n
comment19.params=command
comment19.target=void\ execute(java.lang.Runnable)
comment19.text=\r\n\ Executes\ {@code\ command}\ with\ zero\ required\ delay.\r\n\ This\ has\ effect\ equivalent\ to\r\n\ {@link\ \#schedule(Runnable,long,TimeUnit)\ schedule(command,\ 0,\ anyUnit)}.\r\n\ Note\ that\ inspections\ of\ the\ queue\ and\ of\ the\ list\ returned\ by\r\n\ {@code\ shutdownNow}\ will\ access\ the\ zero-delayed\r\n\ {@link\ ScheduledFuture},\ not\ the\ {@code\ command}\ itself.\r\n\r\n\ <p>A\ consequence\ of\ the\ use\ of\ {@code\ ScheduledFuture}\ objects\ is\r\n\ that\ {@link\ ThreadPoolExecutor\#afterExecute\ afterExecute}\ is\ always\r\n\ called\ with\ a\ null\ second\ {@code\ Throwable}\ argument,\ even\ if\ the\r\n\ {@code\ command}\ terminated\ abruptly.\ \ Instead,\ the\ {@code\ Throwable}\r\n\ thrown\ by\ such\ a\ task\ can\ be\ obtained\ via\ {@link\ Future\#get}.\r\n\r\n\ @throws\ RejectedExecutionException\ at\ discretion\ of\r\n\ \ \ \ \ \ \ \ \ {@code\ RejectedExecutionHandler},\ if\ the\ task\r\n\ \ \ \ \ \ \ \ \ cannot\ be\ accepted\ for\ execution\ because\ the\r\n\ \ \ \ \ \ \ \ \ executor\ has\ been\ shut\ down\r\n\ @throws\ NullPointerException\ {@inheritDoc}\r\n
comment2.params=periodic
comment2.target=boolean\ canRunInCurrentRunState(boolean)
comment2.text=\r\n\ Returns\ true\ if\ can\ run\ a\ task\ given\ current\ run\ state\r\n\ and\ run-after-shutdown\ parameters.\r\n\r\n\ @param\ periodic\ true\ if\ this\ task\ periodic,\ false\ if\ delayed\r\n
comment20.params=task
comment20.target=Future\ submit(java.lang.Runnable)
comment20.text=\r\n\ @throws\ RejectedExecutionException\ {@inheritDoc}\r\n\ @throws\ NullPointerException\ \ \ \ \ \ \ {@inheritDoc}\r\n
comment21.params=task\ result
comment21.target=Future\ submit(java.lang.Runnable,\ java.lang.Object)
comment21.text=\r\n\ @throws\ RejectedExecutionException\ {@inheritDoc}\r\n\ @throws\ NullPointerException\ \ \ \ \ \ \ {@inheritDoc}\r\n
comment22.params=task
comment22.target=Future\ submit(Callable)
comment22.text=\r\n\ @throws\ RejectedExecutionException\ {@inheritDoc}\r\n\ @throws\ NullPointerException\ \ \ \ \ \ \ {@inheritDoc}\r\n
comment23.params=value
comment23.target=void\ setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean)
comment23.text=\r\n\ Sets\ the\ policy\ on\ whether\ to\ continue\ executing\ existing\r\n\ periodic\ tasks\ even\ when\ this\ executor\ has\ been\ {@code\ shutdown}.\r\n\ In\ this\ case,\ these\ tasks\ will\ only\ terminate\ upon\r\n\ {@code\ shutdownNow}\ or\ after\ setting\ the\ policy\ to\r\n\ {@code\ false}\ when\ already\ shutdown.\r\n\ This\ value\ is\ by\ default\ {@code\ false}.\r\n\r\n\ @param\ value\ if\ {@code\ true},\ continue\ after\ shutdown,\ else\ don't.\r\n\ @see\ \#getContinueExistingPeriodicTasksAfterShutdownPolicy\r\n
comment24.params=
comment24.target=boolean\ getContinueExistingPeriodicTasksAfterShutdownPolicy()
comment24.text=\r\n\ Gets\ the\ policy\ on\ whether\ to\ continue\ executing\ existing\r\n\ periodic\ tasks\ even\ when\ this\ executor\ has\ been\ {@code\ shutdown}.\r\n\ In\ this\ case,\ these\ tasks\ will\ only\ terminate\ upon\r\n\ {@code\ shutdownNow}\ or\ after\ setting\ the\ policy\ to\r\n\ {@code\ false}\ when\ already\ shutdown.\r\n\ This\ value\ is\ by\ default\ {@code\ false}.\r\n\r\n\ @return\ {@code\ true}\ if\ will\ continue\ after\ shutdown\r\n\ @see\ \#setContinueExistingPeriodicTasksAfterShutdownPolicy\r\n
comment25.params=value
comment25.target=void\ setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean)
comment25.text=\r\n\ Sets\ the\ policy\ on\ whether\ to\ execute\ existing\ delayed\r\n\ tasks\ even\ when\ this\ executor\ has\ been\ {@code\ shutdown}.\r\n\ In\ this\ case,\ these\ tasks\ will\ only\ terminate\ upon\r\n\ {@code\ shutdownNow},\ or\ after\ setting\ the\ policy\ to\r\n\ {@code\ false}\ when\ already\ shutdown.\r\n\ This\ value\ is\ by\ default\ {@code\ true}.\r\n\r\n\ @param\ value\ if\ {@code\ true},\ execute\ after\ shutdown,\ else\ don't.\r\n\ @see\ \#getExecuteExistingDelayedTasksAfterShutdownPolicy\r\n
comment26.params=
comment26.target=boolean\ getExecuteExistingDelayedTasksAfterShutdownPolicy()
comment26.text=\r\n\ Gets\ the\ policy\ on\ whether\ to\ execute\ existing\ delayed\r\n\ tasks\ even\ when\ this\ executor\ has\ been\ {@code\ shutdown}.\r\n\ In\ this\ case,\ these\ tasks\ will\ only\ terminate\ upon\r\n\ {@code\ shutdownNow},\ or\ after\ setting\ the\ policy\ to\r\n\ {@code\ false}\ when\ already\ shutdown.\r\n\ This\ value\ is\ by\ default\ {@code\ true}.\r\n\r\n\ @return\ {@code\ true}\ if\ will\ execute\ after\ shutdown\r\n\ @see\ \#setExecuteExistingDelayedTasksAfterShutdownPolicy\r\n
comment27.params=value
comment27.target=void\ setRemoveOnCancelPolicy(boolean)
comment27.text=\r\n\ Sets\ the\ policy\ on\ whether\ cancelled\ tasks\ should\ be\ immediately\r\n\ removed\ from\ the\ work\ queue\ at\ time\ of\ cancellation.\ \ This\ value\ is\r\n\ by\ default\ {@code\ false}.\r\n\r\n\ @param\ value\ if\ {@code\ true},\ remove\ on\ cancellation,\ else\ don't\r\n\ @see\ \#getRemoveOnCancelPolicy\r\n\ @since\ 1.7\r\n
comment28.params=
comment28.target=boolean\ getRemoveOnCancelPolicy()
comment28.text=\r\n\ Gets\ the\ policy\ on\ whether\ cancelled\ tasks\ should\ be\ immediately\r\n\ removed\ from\ the\ work\ queue\ at\ time\ of\ cancellation.\ \ This\ value\ is\r\n\ by\ default\ {@code\ false}.\r\n\r\n\ @return\ {@code\ true}\ if\ cancelled\ tasks\ are\ immediately\ removed\r\n\ \ \ \ \ \ \ \ \ from\ the\ queue\r\n\ @see\ \#setRemoveOnCancelPolicy\r\n\ @since\ 1.7\r\n
comment29.params=
comment29.target=void\ shutdown()
comment29.text=\r\n\ Initiates\ an\ orderly\ shutdown\ in\ which\ previously\ submitted\r\n\ tasks\ are\ executed,\ but\ no\ new\ tasks\ will\ be\ accepted.\r\n\ Invocation\ has\ no\ additional\ effect\ if\ already\ shut\ down.\r\n\r\n\ <p>This\ method\ does\ not\ wait\ for\ previously\ submitted\ tasks\ to\r\n\ complete\ execution.\ \ Use\ {@link\ \#awaitTermination\ awaitTermination}\r\n\ to\ do\ that.\r\n\r\n\ <p>If\ the\ {@code\ ExecuteExistingDelayedTasksAfterShutdownPolicy}\r\n\ has\ been\ set\ {@code\ false},\ existing\ delayed\ tasks\ whose\ delays\r\n\ have\ not\ yet\ elapsed\ are\ cancelled.\ \ And\ unless\ the\ {@code\r\n\ ContinueExistingPeriodicTasksAfterShutdownPolicy}\ has\ been\ set\r\n\ {@code\ true},\ future\ executions\ of\ existing\ periodic\ tasks\ will\r\n\ be\ cancelled.\r\n\r\n\ @throws\ SecurityException\ {@inheritDoc}\r\n
comment3.params=task
comment3.target=void\ delayedExecute(RunnableScheduledFuture)
comment3.text=\r\n\ Main\ execution\ method\ for\ delayed\ or\ periodic\ tasks.\ \ If\ pool\r\n\ is\ shut\ down,\ rejects\ the\ task.\ Otherwise\ adds\ task\ to\ queue\r\n\ and\ starts\ a\ thread,\ if\ necessary,\ to\ run\ it.\ \ (We\ cannot\r\n\ prestart\ the\ thread\ to\ run\ the\ task\ because\ the\ task\ (probably)\r\n\ shouldn't\ be\ run\ yet,)\ If\ the\ pool\ is\ shut\ down\ while\ the\ task\r\n\ is\ being\ added,\ cancel\ and\ remove\ it\ if\ required\ by\ state\ and\r\n\ run-after-shutdown\ parameters.\r\n\r\n\ @param\ task\ the\ task\r\n
comment30.params=
comment30.target=java.util.List\ shutdownNow()
comment30.text=\r\n\ Attempts\ to\ stop\ all\ actively\ executing\ tasks,\ halts\ the\r\n\ processing\ of\ waiting\ tasks,\ and\ returns\ a\ list\ of\ the\ tasks\r\n\ that\ were\ awaiting\ execution.\r\n\r\n\ <p>This\ method\ does\ not\ wait\ for\ actively\ executing\ tasks\ to\r\n\ terminate.\ \ Use\ {@link\ \#awaitTermination\ awaitTermination}\ to\r\n\ do\ that.\r\n\r\n\ <p>There\ are\ no\ guarantees\ beyond\ best-effort\ attempts\ to\ stop\r\n\ processing\ actively\ executing\ tasks.\ \ This\ implementation\r\n\ cancels\ tasks\ via\ {@link\ Thread\#interrupt},\ so\ any\ task\ that\r\n\ fails\ to\ respond\ to\ interrupts\ may\ never\ terminate.\r\n\r\n\ @return\ list\ of\ tasks\ that\ never\ commenced\ execution.\r\n\ \ \ \ \ \ \ \ \ Each\ element\ of\ this\ list\ is\ a\ {@link\ ScheduledFuture},\r\n\ \ \ \ \ \ \ \ \ including\ those\ tasks\ submitted\ using\ {@code\ execute},\r\n\ \ \ \ \ \ \ \ \ which\ are\ for\ scheduling\ purposes\ used\ as\ the\ basis\ of\ a\r\n\ \ \ \ \ \ \ \ \ zero-delay\ {@code\ ScheduledFuture}.\r\n\ @throws\ SecurityException\ {@inheritDoc}\r\n
comment31.params=
comment31.target=BlockingQueue\ getQueue()
comment31.text=\r\n\ Returns\ the\ task\ queue\ used\ by\ this\ executor.\ \ Each\ element\ of\r\n\ this\ queue\ is\ a\ {@link\ ScheduledFuture},\ including\ those\r\n\ tasks\ submitted\ using\ {@code\ execute}\ which\ are\ for\ scheduling\r\n\ purposes\ used\ as\ the\ basis\ of\ a\ zero-delay\r\n\ {@code\ ScheduledFuture}.\ \ Iteration\ over\ this\ queue\ is\r\n\ <em>not</em>\ guaranteed\ to\ traverse\ tasks\ in\ the\ order\ in\r\n\ which\ they\ will\ execute.\r\n\r\n\ @return\ the\ task\ queue\r\n
comment4.params=task
comment4.target=void\ reExecutePeriodic(RunnableScheduledFuture)
comment4.text=\r\n\ Requeues\ a\ periodic\ task\ unless\ current\ run\ state\ precludes\ it.\r\n\ Same\ idea\ as\ delayedExecute\ except\ drops\ task\ rather\ than\ rejecting.\r\n\r\n\ @param\ task\ the\ task\r\n
comment5.params=
comment5.target=void\ onShutdown()
comment5.text=\r\n\ Cancels\ and\ clears\ the\ queue\ of\ all\ tasks\ that\ should\ not\ be\ run\r\n\ due\ to\ shutdown\ policy.\ \ Invoked\ within\ super.shutdown.\r\n
comment6.params=runnable\ task
comment6.target=RunnableScheduledFuture\ decorateTask(java.lang.Runnable,\ RunnableScheduledFuture)
comment6.text=\r\n\ Modifies\ or\ replaces\ the\ task\ used\ to\ execute\ a\ runnable.\r\n\ This\ method\ can\ be\ used\ to\ override\ the\ concrete\r\n\ class\ used\ for\ managing\ internal\ tasks.\r\n\ The\ default\ implementation\ simply\ returns\ the\ given\ task.\r\n\r\n\ @param\ runnable\ the\ submitted\ Runnable\r\n\ @param\ task\ the\ task\ created\ to\ execute\ the\ runnable\r\n\ @return\ a\ task\ that\ can\ execute\ the\ runnable\r\n\ @since\ 1.6\r\n
comment7.params=callable\ task
comment7.target=RunnableScheduledFuture\ decorateTask(Callable,\ RunnableScheduledFuture)
comment7.text=\r\n\ Modifies\ or\ replaces\ the\ task\ used\ to\ execute\ a\ callable.\r\n\ This\ method\ can\ be\ used\ to\ override\ the\ concrete\r\n\ class\ used\ for\ managing\ internal\ tasks.\r\n\ The\ default\ implementation\ simply\ returns\ the\ given\ task.\r\n\r\n\ @param\ callable\ the\ submitted\ Callable\r\n\ @param\ task\ the\ task\ created\ to\ execute\ the\ callable\r\n\ @return\ a\ task\ that\ can\ execute\ the\ callable\r\n\ @since\ 1.6\r\n
comment8.params=corePoolSize
comment8.target=ScheduledThreadPoolExecutor(int)
comment8.text=\r\n\ Creates\ a\ new\ {@code\ ScheduledThreadPoolExecutor}\ with\ the\r\n\ given\ core\ pool\ size.\r\n\r\n\ @param\ corePoolSize\ the\ number\ of\ threads\ to\ keep\ in\ the\ pool,\ even\r\n\ \ \ \ \ \ \ \ if\ they\ are\ idle,\ unless\ {@code\ allowCoreThreadTimeOut}\ is\ set\r\n\ @throws\ IllegalArgumentException\ if\ {@code\ corePoolSize\ <\ 0}\r\n
comment9.params=corePoolSize\ threadFactory
comment9.target=ScheduledThreadPoolExecutor(int,\ ThreadFactory)
comment9.text=\r\n\ Creates\ a\ new\ {@code\ ScheduledThreadPoolExecutor}\ with\ the\r\n\ given\ initial\ parameters.\r\n\r\n\ @param\ corePoolSize\ the\ number\ of\ threads\ to\ keep\ in\ the\ pool,\ even\r\n\ \ \ \ \ \ \ \ if\ they\ are\ idle,\ unless\ {@code\ allowCoreThreadTimeOut}\ is\ set\r\n\ @param\ threadFactory\ the\ factory\ to\ use\ when\ the\ executor\r\n\ \ \ \ \ \ \ \ creates\ a\ new\ thread\r\n\ @throws\ IllegalArgumentException\ if\ {@code\ corePoolSize\ <\ 0}\r\n\ @throws\ NullPointerException\ if\ {@code\ threadFactory}\ is\ null\r\n
numComments=32
