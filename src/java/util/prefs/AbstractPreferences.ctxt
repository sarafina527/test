#BlueJ class context
comment0.target=AbstractPreferences
comment0.text=\r\n\ This\ class\ provides\ a\ skeletal\ implementation\ of\ the\ {@link\ Preferences}\r\n\ class,\ greatly\ easing\ the\ task\ of\ implementing\ it.\r\n\r\n\ <p><strong>This\ class\ is\ for\ <tt>Preferences</tt>\ implementers\ only.\r\n\ Normal\ users\ of\ the\ <tt>Preferences</tt>\ facility\ should\ have\ no\ need\ to\r\n\ consult\ this\ documentation.\ \ The\ {@link\ Preferences}\ documentation\r\n\ should\ suffice.</strong>\r\n\r\n\ <p>Implementors\ must\ override\ the\ nine\ abstract\ service-provider\ interface\r\n\ (SPI)\ methods\:\ {@link\ \#getSpi(String)},\ {@link\ \#putSpi(String,String)},\r\n\ {@link\ \#removeSpi(String)},\ {@link\ \#childSpi(String)},\ {@link\r\n\ \#removeNodeSpi()},\ {@link\ \#keysSpi()},\ {@link\ \#childrenNamesSpi()},\ {@link\r\n\ \#syncSpi()}\ and\ {@link\ \#flushSpi()}.\ \ All\ of\ the\ concrete\ methods\ specify\r\n\ precisely\ how\ they\ are\ implemented\ atop\ these\ SPI\ methods.\ \ The\ implementor\r\n\ may,\ at\ his\ discretion,\ override\ one\ or\ more\ of\ the\ concrete\ methods\ if\ the\r\n\ default\ implementation\ is\ unsatisfactory\ for\ any\ reason,\ such\ as\r\n\ performance.\r\n\r\n\ <p>The\ SPI\ methods\ fall\ into\ three\ groups\ concerning\ exception\r\n\ behavior.\ The\ <tt>getSpi</tt>\ method\ should\ never\ throw\ exceptions,\ but\ it\r\n\ doesn't\ really\ matter,\ as\ any\ exception\ thrown\ by\ this\ method\ will\ be\r\n\ intercepted\ by\ {@link\ \#get(String,String)},\ which\ will\ return\ the\ specified\r\n\ default\ value\ to\ the\ caller.\ \ The\ <tt>removeNodeSpi,\ keysSpi,\r\n\ childrenNamesSpi,\ syncSpi</tt>\ and\ <tt>flushSpi</tt>\ methods\ are\ specified\r\n\ to\ throw\ {@link\ BackingStoreException},\ and\ the\ implementation\ is\ required\r\n\ to\ throw\ this\ checked\ exception\ if\ it\ is\ unable\ to\ perform\ the\ operation.\r\n\ The\ exception\ propagates\ outward,\ causing\ the\ corresponding\ API\ method\r\n\ to\ fail.\r\n\r\n\ <p>The\ remaining\ SPI\ methods\ {@link\ \#putSpi(String,String)},\ {@link\r\n\ \#removeSpi(String)}\ and\ {@link\ \#childSpi(String)}\ have\ more\ complicated\r\n\ exception\ behavior.\ \ They\ are\ not\ specified\ to\ throw\r\n\ <tt>BackingStoreException</tt>,\ as\ they\ can\ generally\ obey\ their\ contracts\r\n\ even\ if\ the\ backing\ store\ is\ unavailable.\ \ This\ is\ true\ because\ they\ return\r\n\ no\ information\ and\ their\ effects\ are\ not\ required\ to\ become\ permanent\ until\r\n\ a\ subsequent\ call\ to\ {@link\ Preferences\#flush()}\ or\r\n\ {@link\ Preferences\#sync()}.\ Generally\ speaking,\ these\ SPI\ methods\ should\ not\r\n\ throw\ exceptions.\ \ In\ some\ implementations,\ there\ may\ be\ circumstances\r\n\ under\ which\ these\ calls\ cannot\ even\ enqueue\ the\ requested\ operation\ for\r\n\ later\ processing.\ \ Even\ under\ these\ circumstances\ it\ is\ generally\ better\ to\r\n\ simply\ ignore\ the\ invocation\ and\ return,\ rather\ than\ throwing\ an\r\n\ exception.\ \ Under\ these\ circumstances,\ however,\ all\ subsequent\ invocations\r\n\ of\ <tt>flush()</tt>\ and\ <tt>sync</tt>\ should\ return\ <tt>false</tt>,\ as\r\n\ returning\ <tt>true</tt>\ would\ imply\ that\ all\ previous\ operations\ had\r\n\ successfully\ been\ made\ permanent.\r\n\r\n\ <p>There\ is\ one\ circumstance\ under\ which\ <tt>putSpi,\ removeSpi\ and\r\n\ childSpi</tt>\ <i>should</i>\ throw\ an\ exception\:\ if\ the\ caller\ lacks\r\n\ sufficient\ privileges\ on\ the\ underlying\ operating\ system\ to\ perform\ the\r\n\ requested\ operation.\ \ This\ will,\ for\ instance,\ occur\ on\ most\ systems\r\n\ if\ a\ non-privileged\ user\ attempts\ to\ modify\ system\ preferences.\r\n\ (The\ required\ privileges\ will\ vary\ from\ implementation\ to\r\n\ implementation.\ \ On\ some\ implementations,\ they\ are\ the\ right\ to\ modify\ the\r\n\ contents\ of\ some\ directory\ in\ the\ file\ system;\ on\ others\ they\ are\ the\ right\r\n\ to\ modify\ contents\ of\ some\ key\ in\ a\ registry.)\ \ Under\ any\ of\ these\r\n\ circumstances,\ it\ would\ generally\ be\ undesirable\ to\ let\ the\ program\r\n\ continue\ executing\ as\ if\ these\ operations\ would\ become\ permanent\ at\ a\ later\r\n\ time.\ \ While\ implementations\ are\ not\ required\ to\ throw\ an\ exception\ under\r\n\ these\ circumstances,\ they\ are\ encouraged\ to\ do\ so.\ \ A\ {@link\r\n\ SecurityException}\ would\ be\ appropriate.\r\n\r\n\ <p>Most\ of\ the\ SPI\ methods\ require\ the\ implementation\ to\ read\ or\ write\r\n\ information\ at\ a\ preferences\ node.\ \ The\ implementor\ should\ beware\ of\ the\r\n\ fact\ that\ another\ VM\ may\ have\ concurrently\ deleted\ this\ node\ from\ the\r\n\ backing\ store.\ \ It\ is\ the\ implementation's\ responsibility\ to\ recreate\ the\r\n\ node\ if\ it\ has\ been\ deleted.\r\n\r\n\ <p>Implementation\ note\:\ In\ Sun's\ default\ <tt>Preferences</tt>\r\n\ implementations,\ the\ user's\ identity\ is\ inherited\ from\ the\ underlying\r\n\ operating\ system\ and\ does\ not\ change\ for\ the\ lifetime\ of\ the\ virtual\r\n\ machine.\ \ It\ is\ recognized\ that\ server-side\ <tt>Preferences</tt>\r\n\ implementations\ may\ have\ the\ user\ identity\ change\ from\ request\ to\ request,\r\n\ implicitly\ passed\ to\ <tt>Preferences</tt>\ methods\ via\ the\ use\ of\ a\r\n\ static\ {@link\ ThreadLocal}\ instance.\ \ Authors\ of\ such\ implementations\ are\r\n\ <i>strongly</i>\ encouraged\ to\ determine\ the\ user\ at\ the\ time\ preferences\r\n\ are\ accessed\ (for\ example\ by\ the\ {@link\ \#get(String,String)}\ or\ {@link\r\n\ \#put(String,String)}\ method)\ rather\ than\ permanently\ associating\ a\ user\r\n\ with\ each\ <tt>Preferences</tt>\ instance.\ \ The\ latter\ behavior\ conflicts\r\n\ with\ normal\ <tt>Preferences</tt>\ usage\ and\ would\ lead\ to\ great\ confusion.\r\n\r\n\ @author\ \ Josh\ Bloch\r\n\ @see\ \ \ \ \ Preferences\r\n\ @since\ \ \ 1.4\r\n
comment1.params=parent\ name
comment1.target=AbstractPreferences(java.util.prefs.AbstractPreferences,\ java.lang.String)
comment1.text=\r\n\ Creates\ a\ preference\ node\ with\ the\ specified\ parent\ and\ the\ specified\r\n\ name\ relative\ to\ its\ parent.\r\n\r\n\ @param\ parent\ the\ parent\ of\ this\ preference\ node,\ or\ null\ if\ this\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ is\ the\ root.\r\n\ @param\ name\ the\ name\ of\ this\ preference\ node,\ relative\ to\ its\ parent,\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ or\ <tt>""</tt>\ if\ this\ is\ the\ root.\r\n\ @throws\ IllegalArgumentException\ if\ <tt>name</tt>\ contains\ a\ slash\r\n\ \ \ \ \ \ \ \ \ \ (<tt>'/'</tt>),\ \ or\ <tt>parent</tt>\ is\ <tt>null</tt>\ and\r\n\ \ \ \ \ \ \ \ \ \ name\ isn't\ <tt>""</tt>.\r\n
comment10.params=key\ value
comment10.target=void\ putBoolean(java.lang.String,\ boolean)
comment10.text=\r\n\ Implements\ the\ <tt>putBoolean</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#putBoolean(String,boolean)}.\r\n\r\n\ <p>This\ implementation\ translates\ <tt>value</tt>\ to\ a\ string\ with\r\n\ {@link\ String\#valueOf(boolean)}\ and\ invokes\ {@link\ \#put(String,String)}\r\n\ on\ the\ result.\r\n\r\n\ @param\ key\ key\ with\ which\ the\ string\ form\ of\ value\ is\ to\ be\ associated.\r\n\ @param\ value\ value\ whose\ string\ form\ is\ to\ be\ associated\ with\ key.\r\n\ @throws\ NullPointerException\ if\ key\ is\ <tt>null</tt>.\r\n\ @throws\ IllegalArgumentException\ if\ <tt>key.length()</tt>\ exceeds\r\n\ \ \ \ \ \ \ \ \ <tt>MAX_KEY_LENGTH</tt>.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment11.params=key\ def
comment11.target=boolean\ getBoolean(java.lang.String,\ boolean)
comment11.text=\r\n\ Implements\ the\ <tt>getBoolean</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#getBoolean(String,boolean)}.\r\n\r\n\ <p>This\ implementation\ invokes\ {@link\ \#get(String,String)\ <tt>get(key,\r\n\ null)</tt>}.\ \ If\ the\ return\ value\ is\ non-null,\ it\ is\ compared\ with\r\n\ <tt>"true"</tt>\ using\ {@link\ String\#equalsIgnoreCase(String)}.\ \ If\ the\r\n\ comparison\ returns\ <tt>true</tt>,\ this\ invocation\ returns\r\n\ <tt>true</tt>.\ \ Otherwise,\ the\ original\ return\ value\ is\ compared\ with\r\n\ <tt>"false"</tt>,\ again\ using\ {@link\ String\#equalsIgnoreCase(String)}.\r\n\ If\ the\ comparison\ returns\ <tt>true</tt>,\ this\ invocation\ returns\r\n\ <tt>false</tt>.\ \ Otherwise,\ this\ invocation\ returns\ <tt>def</tt>.\r\n\r\n\ @param\ key\ key\ whose\ associated\ value\ is\ to\ be\ returned\ as\ a\ boolean.\r\n\ @param\ def\ the\ value\ to\ be\ returned\ in\ the\ event\ that\ this\r\n\ \ \ \ \ \ \ \ preference\ node\ has\ no\ value\ associated\ with\ <tt>key</tt>\r\n\ \ \ \ \ \ \ \ or\ the\ associated\ value\ cannot\ be\ interpreted\ as\ a\ boolean.\r\n\ @return\ the\ boolean\ value\ represented\ by\ the\ string\ associated\ with\r\n\ \ \ \ \ \ \ \ \ <tt>key</tt>\ in\ this\ preference\ node,\ or\ <tt>def</tt>\ if\ the\r\n\ \ \ \ \ \ \ \ \ associated\ value\ does\ not\ exist\ or\ cannot\ be\ interpreted\ as\r\n\ \ \ \ \ \ \ \ \ a\ boolean.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @throws\ NullPointerException\ if\ <tt>key</tt>\ is\ <tt>null</tt>.\r\n
comment12.params=key\ value
comment12.target=void\ putFloat(java.lang.String,\ float)
comment12.text=\r\n\ Implements\ the\ <tt>putFloat</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#putFloat(String,float)}.\r\n\r\n\ <p>This\ implementation\ translates\ <tt>value</tt>\ to\ a\ string\ with\r\n\ {@link\ Float\#toString(float)}\ and\ invokes\ {@link\ \#put(String,String)}\r\n\ on\ the\ result.\r\n\r\n\ @param\ key\ key\ with\ which\ the\ string\ form\ of\ value\ is\ to\ be\ associated.\r\n\ @param\ value\ value\ whose\ string\ form\ is\ to\ be\ associated\ with\ key.\r\n\ @throws\ NullPointerException\ if\ key\ is\ <tt>null</tt>.\r\n\ @throws\ IllegalArgumentException\ if\ <tt>key.length()</tt>\ exceeds\r\n\ \ \ \ \ \ \ \ \ <tt>MAX_KEY_LENGTH</tt>.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment13.params=key\ def
comment13.target=float\ getFloat(java.lang.String,\ float)
comment13.text=\r\n\ Implements\ the\ <tt>getFloat</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#getFloat(String,float)}.\r\n\r\n\ <p>This\ implementation\ invokes\ {@link\ \#get(String,String)\ <tt>get(key,\r\n\ null)</tt>}.\ \ If\ the\ return\ value\ is\ non-null,\ the\ implementation\r\n\ attempts\ to\ translate\ it\ to\ an\ <tt>float</tt>\ with\r\n\ {@link\ Float\#parseFloat(String)}.\ \ If\ the\ attempt\ succeeds,\ the\ return\r\n\ value\ is\ returned\ by\ this\ method.\ \ Otherwise,\ <tt>def</tt>\ is\ returned.\r\n\r\n\ @param\ key\ key\ whose\ associated\ value\ is\ to\ be\ returned\ as\ a\ float.\r\n\ @param\ def\ the\ value\ to\ be\ returned\ in\ the\ event\ that\ this\r\n\ \ \ \ \ \ \ \ preference\ node\ has\ no\ value\ associated\ with\ <tt>key</tt>\r\n\ \ \ \ \ \ \ \ or\ the\ associated\ value\ cannot\ be\ interpreted\ as\ a\ float.\r\n\ @return\ the\ float\ value\ represented\ by\ the\ string\ associated\ with\r\n\ \ \ \ \ \ \ \ \ <tt>key</tt>\ in\ this\ preference\ node,\ or\ <tt>def</tt>\ if\ the\r\n\ \ \ \ \ \ \ \ \ associated\ value\ does\ not\ exist\ or\ cannot\ be\ interpreted\ as\r\n\ \ \ \ \ \ \ \ \ a\ float.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @throws\ NullPointerException\ if\ <tt>key</tt>\ is\ <tt>null</tt>.\r\n
comment14.params=key\ value
comment14.target=void\ putDouble(java.lang.String,\ double)
comment14.text=\r\n\ Implements\ the\ <tt>putDouble</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#putDouble(String,double)}.\r\n\r\n\ <p>This\ implementation\ translates\ <tt>value</tt>\ to\ a\ string\ with\r\n\ {@link\ Double\#toString(double)}\ and\ invokes\ {@link\ \#put(String,String)}\r\n\ on\ the\ result.\r\n\r\n\ @param\ key\ key\ with\ which\ the\ string\ form\ of\ value\ is\ to\ be\ associated.\r\n\ @param\ value\ value\ whose\ string\ form\ is\ to\ be\ associated\ with\ key.\r\n\ @throws\ NullPointerException\ if\ key\ is\ <tt>null</tt>.\r\n\ @throws\ IllegalArgumentException\ if\ <tt>key.length()</tt>\ exceeds\r\n\ \ \ \ \ \ \ \ \ <tt>MAX_KEY_LENGTH</tt>.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment15.params=key\ def
comment15.target=double\ getDouble(java.lang.String,\ double)
comment15.text=\r\n\ Implements\ the\ <tt>getDouble</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#getDouble(String,double)}.\r\n\r\n\ <p>This\ implementation\ invokes\ {@link\ \#get(String,String)\ <tt>get(key,\r\n\ null)</tt>}.\ \ If\ the\ return\ value\ is\ non-null,\ the\ implementation\r\n\ attempts\ to\ translate\ it\ to\ an\ <tt>double</tt>\ with\r\n\ {@link\ Double\#parseDouble(String)}.\ \ If\ the\ attempt\ succeeds,\ the\ return\r\n\ value\ is\ returned\ by\ this\ method.\ \ Otherwise,\ <tt>def</tt>\ is\ returned.\r\n\r\n\ @param\ key\ key\ whose\ associated\ value\ is\ to\ be\ returned\ as\ a\ double.\r\n\ @param\ def\ the\ value\ to\ be\ returned\ in\ the\ event\ that\ this\r\n\ \ \ \ \ \ \ \ preference\ node\ has\ no\ value\ associated\ with\ <tt>key</tt>\r\n\ \ \ \ \ \ \ \ or\ the\ associated\ value\ cannot\ be\ interpreted\ as\ a\ double.\r\n\ @return\ the\ double\ value\ represented\ by\ the\ string\ associated\ with\r\n\ \ \ \ \ \ \ \ \ <tt>key</tt>\ in\ this\ preference\ node,\ or\ <tt>def</tt>\ if\ the\r\n\ \ \ \ \ \ \ \ \ associated\ value\ does\ not\ exist\ or\ cannot\ be\ interpreted\ as\r\n\ \ \ \ \ \ \ \ \ a\ double.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @throws\ NullPointerException\ if\ <tt>key</tt>\ is\ <tt>null</tt>.\r\n
comment16.params=key\ value
comment16.target=void\ putByteArray(java.lang.String,\ byte[])
comment16.text=\r\n\ Implements\ the\ <tt>putByteArray</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#putByteArray(String,byte[])}.\r\n\r\n\ @param\ key\ key\ with\ which\ the\ string\ form\ of\ value\ is\ to\ be\ associated.\r\n\ @param\ value\ value\ whose\ string\ form\ is\ to\ be\ associated\ with\ key.\r\n\ @throws\ NullPointerException\ if\ key\ or\ value\ is\ <tt>null</tt>.\r\n\ @throws\ IllegalArgumentException\ if\ key.length()\ exceeds\ MAX_KEY_LENGTH\r\n\ \ \ \ \ \ \ \ \ or\ if\ value.length\ exceeds\ MAX_VALUE_LENGTH*3/4.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment17.params=key\ def
comment17.target=byte[]\ getByteArray(java.lang.String,\ byte[])
comment17.text=\r\n\ Implements\ the\ <tt>getByteArray</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#getByteArray(String,byte[])}.\r\n\r\n\ @param\ key\ key\ whose\ associated\ value\ is\ to\ be\ returned\ as\ a\ byte\ array.\r\n\ @param\ def\ the\ value\ to\ be\ returned\ in\ the\ event\ that\ this\r\n\ \ \ \ \ \ \ \ preference\ node\ has\ no\ value\ associated\ with\ <tt>key</tt>\r\n\ \ \ \ \ \ \ \ or\ the\ associated\ value\ cannot\ be\ interpreted\ as\ a\ byte\ array.\r\n\ @return\ the\ byte\ array\ value\ represented\ by\ the\ string\ associated\ with\r\n\ \ \ \ \ \ \ \ \ <tt>key</tt>\ in\ this\ preference\ node,\ or\ <tt>def</tt>\ if\ the\r\n\ \ \ \ \ \ \ \ \ associated\ value\ does\ not\ exist\ or\ cannot\ be\ interpreted\ as\r\n\ \ \ \ \ \ \ \ \ a\ byte\ array.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @throws\ NullPointerException\ if\ <tt>key</tt>\ is\ <tt>null</tt>.\ \ (A\r\n\ \ \ \ \ \ \ \ \ <tt>null</tt>\ value\ for\ <tt>def</tt>\ <i>is</i>\ permitted.)\r\n
comment18.params=
comment18.target=java.lang.String[]\ keys()
comment18.text=\r\n\ Implements\ the\ <tt>keys</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#keys()}.\r\n\r\n\ <p>This\ implementation\ obtains\ this\ preference\ node's\ lock,\ checks\ that\r\n\ the\ node\ has\ not\ been\ removed\ and\ invokes\ {@link\ \#keysSpi()}.\r\n\r\n\ @return\ an\ array\ of\ the\ keys\ that\ have\ an\ associated\ value\ in\ this\r\n\ \ \ \ \ \ \ \ \ preference\ node.\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment19.params=
comment19.target=java.lang.String[]\ childrenNames()
comment19.text=\r\n\ Implements\ the\ <tt>children</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#childrenNames()}.\r\n\r\n\ <p>This\ implementation\ obtains\ this\ preference\ node's\ lock,\ checks\ that\r\n\ the\ node\ has\ not\ been\ removed,\ constructs\ a\ <tt>TreeSet</tt>\ initialized\r\n\ to\ the\ names\ of\ children\ already\ cached\ (the\ children\ in\ this\ node's\r\n\ "child-cache"),\ invokes\ {@link\ \#childrenNamesSpi()},\ and\ adds\ all\ of\ the\r\n\ returned\ child-names\ into\ the\ set.\ \ The\ elements\ of\ the\ tree\ set\ are\r\n\ dumped\ into\ a\ <tt>String</tt>\ array\ using\ the\ <tt>toArray</tt>\ method,\r\n\ and\ this\ array\ is\ returned.\r\n\r\n\ @return\ the\ names\ of\ the\ children\ of\ this\ preference\ node.\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @see\ \#cachedChildren()\r\n
comment2.params=key\ value
comment2.target=void\ put(java.lang.String,\ java.lang.String)
comment2.text=\r\n\ Implements\ the\ <tt>put</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#put(String,String)}.\r\n\r\n\ <p>This\ implementation\ checks\ that\ the\ key\ and\ value\ are\ legal,\r\n\ obtains\ this\ preference\ node's\ lock,\ checks\ that\ the\ node\r\n\ has\ not\ been\ removed,\ invokes\ {@link\ \#putSpi(String,String)},\ and\ if\r\n\ there\ are\ any\ preference\ change\ listeners,\ enqueues\ a\ notification\r\n\ event\ for\ processing\ by\ the\ event\ dispatch\ thread.\r\n\r\n\ @param\ key\ key\ with\ which\ the\ specified\ value\ is\ to\ be\ associated.\r\n\ @param\ value\ value\ to\ be\ associated\ with\ the\ specified\ key.\r\n\ @throws\ NullPointerException\ if\ key\ or\ value\ is\ <tt>null</tt>.\r\n\ @throws\ IllegalArgumentException\ if\ <tt>key.length()</tt>\ exceeds\r\n\ \ \ \ \ \ \ <tt>MAX_KEY_LENGTH</tt>\ or\ if\ <tt>value.length</tt>\ exceeds\r\n\ \ \ \ \ \ \ <tt>MAX_VALUE_LENGTH</tt>.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment20.params=
comment20.target=java.util.prefs.AbstractPreferences[]\ cachedChildren()
comment20.text=\r\n\ Returns\ all\ known\ unremoved\ children\ of\ this\ node.\r\n\r\n\ @return\ all\ known\ unremoved\ children\ of\ this\ node.\r\n
comment21.params=
comment21.target=java.util.prefs.Preferences\ parent()
comment21.text=\r\n\ Implements\ the\ <tt>parent</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#parent()}.\r\n\r\n\ <p>This\ implementation\ obtains\ this\ preference\ node's\ lock,\ checks\ that\r\n\ the\ node\ has\ not\ been\ removed\ and\ returns\ the\ parent\ value\ that\ was\r\n\ passed\ to\ this\ node's\ constructor.\r\n\r\n\ @return\ the\ parent\ of\ this\ preference\ node.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment22.params=path
comment22.target=java.util.prefs.Preferences\ node(java.lang.String)
comment22.text=\r\n\ Implements\ the\ <tt>node</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#node(String)}.\r\n\r\n\ <p>This\ implementation\ obtains\ this\ preference\ node's\ lock\ and\ checks\r\n\ that\ the\ node\ has\ not\ been\ removed.\ \ If\ <tt>path</tt>\ is\ <tt>""</tt>,\r\n\ this\ node\ is\ returned;\ if\ <tt>path</tt>\ is\ <tt>"/"</tt>,\ this\ node's\r\n\ root\ is\ returned.\ \ If\ the\ first\ character\ in\ <tt>path</tt>\ is\r\n\ not\ <tt>'/'</tt>,\ the\ implementation\ breaks\ <tt>path</tt>\ into\r\n\ tokens\ and\ recursively\ traverses\ the\ path\ from\ this\ node\ to\ the\r\n\ named\ node,\ "consuming"\ a\ name\ and\ a\ slash\ from\ <tt>path</tt>\ at\r\n\ each\ step\ of\ the\ traversal.\ \ At\ each\ step,\ the\ current\ node\ is\ locked\r\n\ and\ the\ node's\ child-cache\ is\ checked\ for\ the\ named\ node.\ \ If\ it\ is\r\n\ not\ found,\ the\ name\ is\ checked\ to\ make\ sure\ its\ length\ does\ not\r\n\ exceed\ <tt>MAX_NAME_LENGTH</tt>.\ \ Then\ the\ {@link\ \#childSpi(String)}\r\n\ method\ is\ invoked,\ and\ the\ result\ stored\ in\ this\ node's\ child-cache.\r\n\ If\ the\ newly\ created\ <tt>Preferences</tt>\ object's\ {@link\ \#newNode}\r\n\ field\ is\ <tt>true</tt>\ and\ there\ are\ any\ node\ change\ listeners,\r\n\ a\ notification\ event\ is\ enqueued\ for\ processing\ by\ the\ event\ dispatch\r\n\ thread.\r\n\r\n\ <p>When\ there\ are\ no\ more\ tokens,\ the\ last\ value\ found\ in\ the\r\n\ child-cache\ or\ returned\ by\ <tt>childSpi</tt>\ is\ returned\ by\ this\r\n\ method.\ \ If\ during\ the\ traversal,\ two\ <tt>"/"</tt>\ tokens\ occur\r\n\ consecutively,\ or\ the\ final\ token\ is\ <tt>"/"</tt>\ (rather\ than\ a\ name),\r\n\ an\ appropriate\ <tt>IllegalArgumentException</tt>\ is\ thrown.\r\n\r\n\ <p>\ If\ the\ first\ character\ of\ <tt>path</tt>\ is\ <tt>'/'</tt>\r\n\ (indicating\ an\ absolute\ path\ name)\ this\ preference\ node's\r\n\ lock\ is\ dropped\ prior\ to\ breaking\ <tt>path</tt>\ into\ tokens,\ and\r\n\ this\ method\ recursively\ traverses\ the\ path\ starting\ from\ the\ root\r\n\ (rather\ than\ starting\ from\ this\ node).\ \ The\ traversal\ is\ otherwise\r\n\ identical\ to\ the\ one\ described\ for\ relative\ path\ names.\ \ Dropping\r\n\ the\ lock\ on\ this\ node\ prior\ to\ commencing\ the\ traversal\ at\ the\ root\r\n\ node\ is\ essential\ to\ avoid\ the\ possibility\ of\ deadlock,\ as\ per\ the\r\n\ {@link\ \#lock\ locking\ invariant}.\r\n\r\n\ @param\ path\ the\ path\ name\ of\ the\ preference\ node\ to\ return.\r\n\ @return\ the\ specified\ preference\ node.\r\n\ @throws\ IllegalArgumentException\ if\ the\ path\ name\ is\ invalid\ (i.e.,\r\n\ \ \ \ \ \ \ \ \ it\ contains\ multiple\ consecutive\ slash\ characters,\ or\ ends\r\n\ \ \ \ \ \ \ \ \ with\ a\ slash\ character\ and\ is\ more\ than\ one\ character\ long).\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment23.params=path
comment23.target=java.util.prefs.Preferences\ node(java.util.StringTokenizer)
comment23.text=\r\n\ tokenizer\ contains\ <name>\ {'/'\ <name>}*\r\n
comment24.params=path
comment24.target=boolean\ nodeExists(java.lang.String)
comment24.text=\r\n\ Implements\ the\ <tt>nodeExists</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#nodeExists(String)}.\r\n\r\n\ <p>This\ implementation\ is\ very\ similar\ to\ {@link\ \#node(String)},\r\n\ except\ that\ {@link\ \#getChild(String)}\ is\ used\ instead\ of\ {@link\r\n\ \#childSpi(String)}.\r\n\r\n\ @param\ path\ the\ path\ name\ of\ the\ node\ whose\ existence\ is\ to\ be\ checked.\r\n\ @return\ true\ if\ the\ specified\ node\ exists.\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n\ @throws\ IllegalArgumentException\ if\ the\ path\ name\ is\ invalid\ (i.e.,\r\n\ \ \ \ \ \ \ \ \ it\ contains\ multiple\ consecutive\ slash\ characters,\ or\ ends\r\n\ \ \ \ \ \ \ \ \ with\ a\ slash\ character\ and\ is\ more\ than\ one\ character\ long).\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method\ and\r\n\ \ \ \ \ \ \ \ \ <tt>pathname</tt>\ is\ not\ the\ empty\ string\ (<tt>""</tt>).\r\n
comment25.params=path
comment25.target=boolean\ nodeExists(java.util.StringTokenizer)
comment25.text=\r\n\ tokenizer\ contains\ <name>\ {'/'\ <name>}*\r\n
comment26.params=
comment26.target=void\ removeNode()
comment26.text=\r\n\r\n\ Implements\ the\ <tt>removeNode()</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#removeNode()}.\r\n\r\n\ <p>This\ implementation\ checks\ to\ see\ that\ this\ node\ is\ the\ root;\ if\ so,\r\n\ it\ throws\ an\ appropriate\ exception.\ \ Then,\ it\ locks\ this\ node's\ parent,\r\n\ and\ calls\ a\ recursive\ helper\ method\ that\ traverses\ the\ subtree\ rooted\ at\r\n\ this\ node.\ \ The\ recursive\ method\ locks\ the\ node\ on\ which\ it\ was\ called,\r\n\ checks\ that\ it\ has\ not\ already\ been\ removed,\ and\ then\ ensures\ that\ all\r\n\ of\ its\ children\ are\ cached\:\ The\ {@link\ \#childrenNamesSpi()}\ method\ is\r\n\ invoked\ and\ each\ returned\ child\ name\ is\ checked\ for\ containment\ in\ the\r\n\ child-cache.\ \ If\ a\ child\ is\ not\ already\ cached,\ the\ {@link\r\n\ \#childSpi(String)}\ method\ is\ invoked\ to\ create\ a\ <tt>Preferences</tt>\r\n\ instance\ for\ it,\ and\ this\ instance\ is\ put\ into\ the\ child-cache.\ \ Then\r\n\ the\ helper\ method\ calls\ itself\ recursively\ on\ each\ node\ contained\ in\ its\r\n\ child-cache.\ \ Next,\ it\ invokes\ {@link\ \#removeNodeSpi()},\ marks\ itself\r\n\ as\ removed,\ and\ removes\ itself\ from\ its\ parent's\ child-cache.\ \ Finally,\r\n\ if\ there\ are\ any\ node\ change\ listeners,\ it\ enqueues\ a\ notification\r\n\ event\ for\ processing\ by\ the\ event\ dispatch\ thread.\r\n\r\n\ <p>Note\ that\ the\ helper\ method\ is\ always\ invoked\ with\ all\ ancestors\ up\r\n\ to\ the\ "closest\ non-removed\ ancestor"\ locked.\r\n\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ already\r\n\ \ \ \ \ \ \ \ \ been\ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @throws\ UnsupportedOperationException\ if\ this\ method\ is\ invoked\ on\r\n\ \ \ \ \ \ \ \ \ the\ root\ node.\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n
comment27.params=
comment27.target=void\ removeNode2()
comment27.text=\r\n\ Called\ with\ locks\ on\ all\ nodes\ on\ path\ from\ parent\ of\ "removal\ root"\r\n\ to\ this\ (including\ the\ former\ but\ excluding\ the\ latter).\r\n
comment28.params=
comment28.target=java.lang.String\ name()
comment28.text=\r\n\ Implements\ the\ <tt>name</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#name()}.\r\n\r\n\ <p>This\ implementation\ merely\ returns\ the\ name\ that\ was\r\n\ passed\ to\ this\ node's\ constructor.\r\n\r\n\ @return\ this\ preference\ node's\ name,\ relative\ to\ its\ parent.\r\n
comment29.params=
comment29.target=java.lang.String\ absolutePath()
comment29.text=\r\n\ Implements\ the\ <tt>absolutePath</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#absolutePath()}.\r\n\r\n\ <p>This\ implementation\ merely\ returns\ the\ absolute\ path\ name\ that\r\n\ was\ computed\ at\ the\ time\ that\ this\ node\ was\ constructed\ (based\ on\r\n\ the\ name\ that\ was\ passed\ to\ this\ node's\ constructor,\ and\ the\ names\r\n\ that\ were\ passed\ to\ this\ node's\ ancestors'\ constructors).\r\n\r\n\ @return\ this\ preference\ node's\ absolute\ path\ name.\r\n
comment3.params=key\ def
comment3.target=java.lang.String\ get(java.lang.String,\ java.lang.String)
comment3.text=\r\n\ Implements\ the\ <tt>get</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#get(String,String)}.\r\n\r\n\ <p>This\ implementation\ first\ checks\ to\ see\ if\ <tt>key</tt>\ is\r\n\ <tt>null</tt>\ throwing\ a\ <tt>NullPointerException</tt>\ if\ this\ is\r\n\ the\ case.\ \ Then\ it\ obtains\ this\ preference\ node's\ lock,\r\n\ checks\ that\ the\ node\ has\ not\ been\ removed,\ invokes\ {@link\r\n\ \#getSpi(String)},\ and\ returns\ the\ result,\ unless\ the\ <tt>getSpi</tt>\r\n\ invocation\ returns\ <tt>null</tt>\ or\ throws\ an\ exception,\ in\ which\ case\r\n\ this\ invocation\ returns\ <tt>def</tt>.\r\n\r\n\ @param\ key\ key\ whose\ associated\ value\ is\ to\ be\ returned.\r\n\ @param\ def\ the\ value\ to\ be\ returned\ in\ the\ event\ that\ this\r\n\ \ \ \ \ \ \ \ preference\ node\ has\ no\ value\ associated\ with\ <tt>key</tt>.\r\n\ @return\ the\ value\ associated\ with\ <tt>key</tt>,\ or\ <tt>def</tt>\r\n\ \ \ \ \ \ \ \ \ if\ no\ value\ is\ associated\ with\ <tt>key</tt>.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @throws\ NullPointerException\ if\ key\ is\ <tt>null</tt>.\ \ (A\r\n\ \ \ \ \ \ \ \ \ <tt>null</tt>\ default\ <i>is</i>\ permitted.)\r\n
comment30.params=
comment30.target=boolean\ isUserNode()
comment30.text=\r\n\ Implements\ the\ <tt>isUserNode</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#isUserNode()}.\r\n\r\n\ <p>This\ implementation\ compares\ this\ node's\ root\ node\ (which\ is\ stored\r\n\ in\ a\ private\ field)\ with\ the\ value\ returned\ by\r\n\ {@link\ Preferences\#userRoot()}.\ \ If\ the\ two\ object\ references\ are\r\n\ identical,\ this\ method\ returns\ true.\r\n\r\n\ @return\ <tt>true</tt>\ if\ this\ preference\ node\ is\ in\ the\ user\r\n\ \ \ \ \ \ \ \ \ preference\ tree,\ <tt>false</tt>\ if\ it's\ in\ the\ system\r\n\ \ \ \ \ \ \ \ \ preference\ tree.\r\n
comment31.params=
comment31.target=java.lang.Boolean\ run()
comment32.params=pcl
comment32.target=void\ addPreferenceChangeListener(java.util.prefs.PreferenceChangeListener)
comment33.params=pcl
comment33.target=void\ removePreferenceChangeListener(java.util.prefs.PreferenceChangeListener)
comment34.params=ncl
comment34.target=void\ addNodeChangeListener(java.util.prefs.NodeChangeListener)
comment35.params=ncl
comment35.target=void\ removeNodeChangeListener(java.util.prefs.NodeChangeListener)
comment36.params=key\ value
comment36.target=void\ putSpi(java.lang.String,\ java.lang.String)
comment36.text=\r\n\ Put\ the\ given\ key-value\ association\ into\ this\ preference\ node.\ \ It\ is\r\n\ guaranteed\ that\ <tt>key</tt>\ and\ <tt>value</tt>\ are\ non-null\ and\ of\r\n\ legal\ length.\ \ Also,\ it\ is\ guaranteed\ that\ this\ node\ has\ not\ been\r\n\ removed.\ \ (The\ implementor\ needn't\ check\ for\ any\ of\ these\ things.)\r\n\r\n\ <p>This\ method\ is\ invoked\ with\ the\ lock\ on\ this\ node\ held.\r\n
comment37.params=key
comment37.target=java.lang.String\ getSpi(java.lang.String)
comment37.text=\r\n\ Return\ the\ value\ associated\ with\ the\ specified\ key\ at\ this\ preference\r\n\ node,\ or\ <tt>null</tt>\ if\ there\ is\ no\ association\ for\ this\ key,\ or\ the\r\n\ association\ cannot\ be\ determined\ at\ this\ time.\ \ It\ is\ guaranteed\ that\r\n\ <tt>key</tt>\ is\ non-null.\ \ Also,\ it\ is\ guaranteed\ that\ this\ node\ has\r\n\ not\ been\ removed.\ \ (The\ implementor\ needn't\ check\ for\ either\ of\ these\r\n\ things.)\r\n\r\n\ <p>\ Generally\ speaking,\ this\ method\ should\ not\ throw\ an\ exception\r\n\ under\ any\ circumstances.\ \ If,\ however,\ if\ it\ does\ throw\ an\ exception,\r\n\ the\ exception\ will\ be\ intercepted\ and\ treated\ as\ a\ <tt>null</tt>\r\n\ return\ value.\r\n\r\n\ <p>This\ method\ is\ invoked\ with\ the\ lock\ on\ this\ node\ held.\r\n\r\n\ @return\ the\ value\ associated\ with\ the\ specified\ key\ at\ this\ preference\r\n\ \ \ \ \ \ \ \ \ \ node,\ or\ <tt>null</tt>\ if\ there\ is\ no\ association\ for\ this\r\n\ \ \ \ \ \ \ \ \ \ key,\ or\ the\ association\ cannot\ be\ determined\ at\ this\ time.\r\n
comment38.params=key
comment38.target=void\ removeSpi(java.lang.String)
comment38.text=\r\n\ Remove\ the\ association\ (if\ any)\ for\ the\ specified\ key\ at\ this\r\n\ preference\ node.\ \ It\ is\ guaranteed\ that\ <tt>key</tt>\ is\ non-null.\r\n\ Also,\ it\ is\ guaranteed\ that\ this\ node\ has\ not\ been\ removed.\r\n\ (The\ implementor\ needn't\ check\ for\ either\ of\ these\ things.)\r\n\r\n\ <p>This\ method\ is\ invoked\ with\ the\ lock\ on\ this\ node\ held.\r\n
comment39.params=
comment39.target=void\ removeNodeSpi()
comment39.text=\r\n\ Removes\ this\ preference\ node,\ invalidating\ it\ and\ any\ preferences\ that\r\n\ it\ contains.\ \ The\ named\ child\ will\ have\ no\ descendants\ at\ the\ time\ this\r\n\ invocation\ is\ made\ (i.e.,\ the\ {@link\ Preferences\#removeNode()}\ method\r\n\ invokes\ this\ method\ repeatedly\ in\ a\ bottom-up\ fashion,\ removing\ each\ of\r\n\ a\ node's\ descendants\ before\ removing\ the\ node\ itself).\r\n\r\n\ <p>This\ method\ is\ invoked\ with\ the\ lock\ held\ on\ this\ node\ and\ its\r\n\ parent\ (and\ all\ ancestors\ that\ are\ being\ removed\ as\ a\r\n\ result\ of\ a\ single\ invocation\ to\ {@link\ Preferences\#removeNode()}).\r\n\r\n\ <p>The\ removal\ of\ a\ node\ needn't\ become\ persistent\ until\ the\r\n\ <tt>flush</tt>\ method\ is\ invoked\ on\ this\ node\ (or\ an\ ancestor).\r\n\r\n\ <p>If\ this\ node\ throws\ a\ <tt>BackingStoreException</tt>,\ the\ exception\r\n\ will\ propagate\ out\ beyond\ the\ enclosing\ {@link\ \#removeNode()}\r\n\ invocation.\r\n\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n
comment4.params=key
comment4.target=void\ remove(java.lang.String)
comment4.text=\r\n\ Implements\ the\ <tt>remove(String)</tt>\ method\ as\ per\ the\ specification\r\n\ in\ {@link\ Preferences\#remove(String)}.\r\n\r\n\ <p>This\ implementation\ obtains\ this\ preference\ node's\ lock,\r\n\ checks\ that\ the\ node\ has\ not\ been\ removed,\ invokes\r\n\ {@link\ \#removeSpi(String)}\ and\ if\ there\ are\ any\ preference\r\n\ change\ listeners,\ enqueues\ a\ notification\ event\ for\ processing\ by\ the\r\n\ event\ dispatch\ thread.\r\n\r\n\ @param\ key\ key\ whose\ mapping\ is\ to\ be\ removed\ from\ the\ preference\ node.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment40.params=
comment40.target=java.lang.String[]\ keysSpi()
comment40.text=\r\n\ Returns\ all\ of\ the\ keys\ that\ have\ an\ associated\ value\ in\ this\r\n\ preference\ node.\ \ (The\ returned\ array\ will\ be\ of\ size\ zero\ if\r\n\ this\ node\ has\ no\ preferences.)\ \ It\ is\ guaranteed\ that\ this\ node\ has\ not\r\n\ been\ removed.\r\n\r\n\ <p>This\ method\ is\ invoked\ with\ the\ lock\ on\ this\ node\ held.\r\n\r\n\ <p>If\ this\ node\ throws\ a\ <tt>BackingStoreException</tt>,\ the\ exception\r\n\ will\ propagate\ out\ beyond\ the\ enclosing\ {@link\ \#keys()}\ invocation.\r\n\r\n\ @return\ an\ array\ of\ the\ keys\ that\ have\ an\ associated\ value\ in\ this\r\n\ \ \ \ \ \ \ \ \ preference\ node.\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n
comment41.params=
comment41.target=java.lang.String[]\ childrenNamesSpi()
comment41.text=\r\n\ Returns\ the\ names\ of\ the\ children\ of\ this\ preference\ node.\ \ (The\r\n\ returned\ array\ will\ be\ of\ size\ zero\ if\ this\ node\ has\ no\ children.)\r\n\ This\ method\ need\ not\ return\ the\ names\ of\ any\ nodes\ already\ cached,\r\n\ but\ may\ do\ so\ without\ harm.\r\n\r\n\ <p>This\ method\ is\ invoked\ with\ the\ lock\ on\ this\ node\ held.\r\n\r\n\ <p>If\ this\ node\ throws\ a\ <tt>BackingStoreException</tt>,\ the\ exception\r\n\ will\ propagate\ out\ beyond\ the\ enclosing\ {@link\ \#childrenNames()}\r\n\ invocation.\r\n\r\n\ @return\ an\ array\ containing\ the\ names\ of\ the\ children\ of\ this\r\n\ \ \ \ \ \ \ \ \ preference\ node.\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n
comment42.params=nodeName
comment42.target=java.util.prefs.AbstractPreferences\ getChild(java.lang.String)
comment42.text=\r\n\ Returns\ the\ named\ child\ if\ it\ exists,\ or\ <tt>null</tt>\ if\ it\ does\ not.\r\n\ It\ is\ guaranteed\ that\ <tt>nodeName</tt>\ is\ non-null,\ non-empty,\r\n\ does\ not\ contain\ the\ slash\ character\ ('/'),\ and\ is\ no\ longer\ than\r\n\ {@link\ \#MAX_NAME_LENGTH}\ characters.\ \ Also,\ it\ is\ guaranteed\r\n\ that\ this\ node\ has\ not\ been\ removed.\ \ (The\ implementor\ needn't\ check\r\n\ for\ any\ of\ these\ things\ if\ he\ chooses\ to\ override\ this\ method.)\r\n\r\n\ <p>Finally,\ it\ is\ guaranteed\ that\ the\ named\ node\ has\ not\ been\ returned\r\n\ by\ a\ previous\ invocation\ of\ this\ method\ or\ {@link\ \#childSpi}\ after\ the\r\n\ last\ time\ that\ it\ was\ removed.\ \ In\ other\ words,\ a\ cached\ value\ will\r\n\ always\ be\ used\ in\ preference\ to\ invoking\ this\ method.\ \ (The\ implementor\r\n\ needn't\ maintain\ his\ own\ cache\ of\ previously\ returned\ children\ if\ he\r\n\ chooses\ to\ override\ this\ method.)\r\n\r\n\ <p>This\ implementation\ obtains\ this\ preference\ node's\ lock,\ invokes\r\n\ {@link\ \#childrenNames()}\ to\ get\ an\ array\ of\ the\ names\ of\ this\ node's\r\n\ children,\ and\ iterates\ over\ the\ array\ comparing\ the\ name\ of\ each\ child\r\n\ with\ the\ specified\ node\ name.\ \ If\ a\ child\ node\ has\ the\ correct\ name,\r\n\ the\ {@link\ \#childSpi(String)}\ method\ is\ invoked\ and\ the\ resulting\r\n\ node\ is\ returned.\ \ If\ the\ iteration\ completes\ without\ finding\ the\r\n\ specified\ name,\ <tt>null</tt>\ is\ returned.\r\n\r\n\ @param\ nodeName\ name\ of\ the\ child\ to\ be\ searched\ for.\r\n\ @return\ the\ named\ child\ if\ it\ exists,\ or\ null\ if\ it\ does\ not.\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n
comment43.params=name
comment43.target=java.util.prefs.AbstractPreferences\ childSpi(java.lang.String)
comment43.text=\r\n\ Returns\ the\ named\ child\ of\ this\ preference\ node,\ creating\ it\ if\ it\ does\r\n\ not\ already\ exist.\ \ It\ is\ guaranteed\ that\ <tt>name</tt>\ is\ non-null,\r\n\ non-empty,\ does\ not\ contain\ the\ slash\ character\ ('/'),\ and\ is\ no\ longer\r\n\ than\ {@link\ \#MAX_NAME_LENGTH}\ characters.\ \ Also,\ it\ is\ guaranteed\ that\r\n\ this\ node\ has\ not\ been\ removed.\ \ (The\ implementor\ needn't\ check\ for\ any\r\n\ of\ these\ things.)\r\n\r\n\ <p>Finally,\ it\ is\ guaranteed\ that\ the\ named\ node\ has\ not\ been\ returned\r\n\ by\ a\ previous\ invocation\ of\ this\ method\ or\ {@link\ \#getChild(String)}\r\n\ after\ the\ last\ time\ that\ it\ was\ removed.\ \ In\ other\ words,\ a\ cached\r\n\ value\ will\ always\ be\ used\ in\ preference\ to\ invoking\ this\ method.\r\n\ Subclasses\ need\ not\ maintain\ their\ own\ cache\ of\ previously\ returned\r\n\ children.\r\n\r\n\ <p>The\ implementer\ must\ ensure\ that\ the\ returned\ node\ has\ not\ been\r\n\ removed.\ \ If\ a\ like-named\ child\ of\ this\ node\ was\ previously\ removed,\ the\r\n\ implementer\ must\ return\ a\ newly\ constructed\ <tt>AbstractPreferences</tt>\r\n\ node;\ once\ removed,\ an\ <tt>AbstractPreferences</tt>\ node\r\n\ cannot\ be\ "resuscitated."\r\n\r\n\ <p>If\ this\ method\ causes\ a\ node\ to\ be\ created,\ this\ node\ is\ not\r\n\ guaranteed\ to\ be\ persistent\ until\ the\ <tt>flush</tt>\ method\ is\r\n\ invoked\ on\ this\ node\ or\ one\ of\ its\ ancestors\ (or\ descendants).\r\n\r\n\ <p>This\ method\ is\ invoked\ with\ the\ lock\ on\ this\ node\ held.\r\n\r\n\ @param\ name\ The\ name\ of\ the\ child\ node\ to\ return,\ relative\ to\r\n\ \ \ \ \ \ \ \ this\ preference\ node.\r\n\ @return\ The\ named\ child\ node.\r\n
comment44.params=
comment44.target=java.lang.String\ toString()
comment44.text=\r\n\ Returns\ the\ absolute\ path\ name\ of\ this\ preferences\ node.\r\n
comment45.params=
comment45.target=void\ sync()
comment45.text=\r\n\ Implements\ the\ <tt>sync</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#sync()}.\r\n\r\n\ <p>This\ implementation\ calls\ a\ recursive\ helper\ method\ that\ locks\ this\r\n\ node,\ invokes\ syncSpi()\ on\ it,\ unlocks\ this\ node,\ and\ recursively\r\n\ invokes\ this\ method\ on\ each\ "cached\ child."\ \ A\ cached\ child\ is\ a\ child\r\n\ of\ this\ node\ that\ has\ been\ created\ in\ this\ VM\ and\ not\ subsequently\r\n\ removed.\ \ In\ effect,\ this\ method\ does\ a\ depth\ first\ traversal\ of\ the\r\n\ "cached\ subtree"\ rooted\ at\ this\ node,\ calling\ syncSpi()\ on\ each\ node\ in\r\n\ the\ subTree\ while\ only\ that\ node\ is\ locked.\ Note\ that\ syncSpi()\ is\r\n\ invoked\ top-down.\r\n\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @see\ \#flush()\r\n
comment46.params=
comment46.target=void\ sync2()
comment47.params=
comment47.target=void\ syncSpi()
comment47.text=\r\n\ This\ method\ is\ invoked\ with\ this\ node\ locked.\ \ The\ contract\ of\ this\r\n\ method\ is\ to\ synchronize\ any\ cached\ preferences\ stored\ at\ this\ node\r\n\ with\ any\ stored\ in\ the\ backing\ store.\ \ (It\ is\ perfectly\ possible\ that\r\n\ this\ node\ does\ not\ exist\ on\ the\ backing\ store,\ either\ because\ it\ has\r\n\ been\ deleted\ by\ another\ VM,\ or\ because\ it\ has\ not\ yet\ been\ created.)\r\n\ Note\ that\ this\ method\ should\ <i>not</i>\ synchronize\ the\ preferences\ in\r\n\ any\ subnodes\ of\ this\ node.\ \ If\ the\ backing\ store\ naturally\ syncs\ an\r\n\ entire\ subtree\ at\ once,\ the\ implementer\ is\ encouraged\ to\ override\r\n\ sync(),\ rather\ than\ merely\ overriding\ this\ method.\r\n\r\n\ <p>If\ this\ node\ throws\ a\ <tt>BackingStoreException</tt>,\ the\ exception\r\n\ will\ propagate\ out\ beyond\ the\ enclosing\ {@link\ \#sync()}\ invocation.\r\n\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n
comment48.params=
comment48.target=void\ flush()
comment48.text=\r\n\ Implements\ the\ <tt>flush</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#flush()}.\r\n\r\n\ <p>This\ implementation\ calls\ a\ recursive\ helper\ method\ that\ locks\ this\r\n\ node,\ invokes\ flushSpi()\ on\ it,\ unlocks\ this\ node,\ and\ recursively\r\n\ invokes\ this\ method\ on\ each\ "cached\ child."\ \ A\ cached\ child\ is\ a\ child\r\n\ of\ this\ node\ that\ has\ been\ created\ in\ this\ VM\ and\ not\ subsequently\r\n\ removed.\ \ In\ effect,\ this\ method\ does\ a\ depth\ first\ traversal\ of\ the\r\n\ "cached\ subtree"\ rooted\ at\ this\ node,\ calling\ flushSpi()\ on\ each\ node\ in\r\n\ the\ subTree\ while\ only\ that\ node\ is\ locked.\ Note\ that\ flushSpi()\ is\r\n\ invoked\ top-down.\r\n\r\n\ <p>\ If\ this\ method\ is\ invoked\ on\ a\ node\ that\ has\ been\ removed\ with\r\n\ the\ {@link\ \#removeNode()}\ method,\ flushSpi()\ is\ invoked\ on\ this\ node,\r\n\ but\ not\ on\ others.\r\n\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n\ @see\ \#flush()\r\n
comment49.params=
comment49.target=void\ flush2()
comment5.params=
comment5.target=void\ clear()
comment5.text=\r\n\ Implements\ the\ <tt>clear</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#clear()}.\r\n\r\n\ <p>This\ implementation\ obtains\ this\ preference\ node's\ lock,\r\n\ invokes\ {@link\ \#keys()}\ to\ obtain\ an\ array\ of\ keys,\ and\r\n\ iterates\ over\ the\ array\ invoking\ {@link\ \#remove(String)}\ on\ each\ key.\r\n\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment50.params=
comment50.target=void\ flushSpi()
comment50.text=\r\n\ This\ method\ is\ invoked\ with\ this\ node\ locked.\ \ The\ contract\ of\ this\r\n\ method\ is\ to\ force\ any\ cached\ changes\ in\ the\ contents\ of\ this\r\n\ preference\ node\ to\ the\ backing\ store,\ guaranteeing\ their\ persistence.\r\n\ (It\ is\ perfectly\ possible\ that\ this\ node\ does\ not\ exist\ on\ the\ backing\r\n\ store,\ either\ because\ it\ has\ been\ deleted\ by\ another\ VM,\ or\ because\ it\r\n\ has\ not\ yet\ been\ created.)\ \ Note\ that\ this\ method\ should\ <i>not</i>\r\n\ flush\ the\ preferences\ in\ any\ subnodes\ of\ this\ node.\ \ If\ the\ backing\r\n\ store\ naturally\ flushes\ an\ entire\ subtree\ at\ once,\ the\ implementer\ is\r\n\ encouraged\ to\ override\ flush(),\ rather\ than\ merely\ overriding\ this\r\n\ method.\r\n\r\n\ <p>If\ this\ node\ throws\ a\ <tt>BackingStoreException</tt>,\ the\ exception\r\n\ will\ propagate\ out\ beyond\ the\ enclosing\ {@link\ \#flush()}\ invocation.\r\n\r\n\ @throws\ BackingStoreException\ if\ this\ operation\ cannot\ be\ completed\r\n\ \ \ \ \ \ \ \ \ due\ to\ a\ failure\ in\ the\ backing\ store,\ or\ inability\ to\r\n\ \ \ \ \ \ \ \ \ communicate\ with\ it.\r\n
comment51.params=
comment51.target=boolean\ isRemoved()
comment51.text=\r\n\ Returns\ <tt>true</tt>\ iff\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ removed\ with\ the\ {@link\ \#removeNode()}\ method.\ \ This\ method\r\n\ locks\ this\ node\ prior\ to\ returning\ the\ contents\ of\ the\ private\r\n\ field\ used\ to\ track\ this\ state.\r\n\r\n\ @return\ <tt>true</tt>\ iff\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment52.params=
comment52.target=void\ startEventDispatchThreadIfNecessary()
comment52.text=\r\n\ This\ method\ starts\ the\ event\ dispatch\ thread\ the\ first\ time\ it\r\n\ is\ called.\ \ The\ event\ dispatch\ thread\ will\ be\ started\ only\r\n\ if\ someone\ registers\ a\ listener.\r\n
comment53.params=
comment53.target=java.util.prefs.PreferenceChangeListener[]\ prefListeners()
comment53.text=\r\n\ Return\ this\ node's\ preference/node\ change\ listeners.\ \ Even\ though\r\n\ we're\ using\ a\ copy-on-write\ lists,\ we\ use\ synchronized\ accessors\ to\r\n\ ensure\ information\ transmission\ from\ the\ writing\ thread\ to\ the\r\n\ reading\ thread.\r\n
comment54.params=
comment54.target=java.util.prefs.NodeChangeListener[]\ nodeListeners()
comment55.params=key\ newValue
comment55.target=void\ enqueuePreferenceChangeEvent(java.lang.String,\ java.lang.String)
comment55.text=\r\n\ Enqueue\ a\ preference\ change\ event\ for\ delivery\ to\ registered\r\n\ preference\ change\ listeners\ unless\ there\ are\ no\ registered\r\n\ listeners.\ \ Invoked\ with\ this.lock\ held.\r\n
comment56.params=child
comment56.target=void\ enqueueNodeAddedEvent(java.util.prefs.Preferences)
comment56.text=\r\n\ Enqueue\ a\ "node\ added"\ event\ for\ delivery\ to\ registered\ node\ change\r\n\ listeners\ unless\ there\ are\ no\ registered\ listeners.\ \ Invoked\ with\r\n\ this.lock\ held.\r\n
comment57.params=child
comment57.target=void\ enqueueNodeRemovedEvent(java.util.prefs.Preferences)
comment57.text=\r\n\ Enqueue\ a\ "node\ removed"\ event\ for\ delivery\ to\ registered\ node\ change\r\n\ listeners\ unless\ there\ are\ no\ registered\ listeners.\ \ Invoked\ with\r\n\ this.lock\ held.\r\n
comment58.params=os
comment58.target=void\ exportNode(java.io.OutputStream)
comment58.text=\r\n\ Implements\ the\ <tt>exportNode</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#exportNode(OutputStream)}.\r\n\r\n\ @param\ os\ the\ output\ stream\ on\ which\ to\ emit\ the\ XML\ document.\r\n\ @throws\ IOException\ if\ writing\ to\ the\ specified\ output\ stream\r\n\ \ \ \ \ \ \ \ \ results\ in\ an\ <tt>IOException</tt>.\r\n\ @throws\ BackingStoreException\ if\ preference\ data\ cannot\ be\ read\ from\r\n\ \ \ \ \ \ \ \ \ backing\ store.\r\n
comment59.params=os
comment59.target=void\ exportSubtree(java.io.OutputStream)
comment59.text=\r\n\ Implements\ the\ <tt>exportSubtree</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#exportSubtree(OutputStream)}.\r\n\r\n\ @param\ os\ the\ output\ stream\ on\ which\ to\ emit\ the\ XML\ document.\r\n\ @throws\ IOException\ if\ writing\ to\ the\ specified\ output\ stream\r\n\ \ \ \ \ \ \ \ \ results\ in\ an\ <tt>IOException</tt>.\r\n\ @throws\ BackingStoreException\ if\ preference\ data\ cannot\ be\ read\ from\r\n\ \ \ \ \ \ \ \ \ backing\ store.\r\n
comment6.params=key\ value
comment6.target=void\ putInt(java.lang.String,\ int)
comment6.text=\r\n\ Implements\ the\ <tt>putInt</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#putInt(String,int)}.\r\n\r\n\ <p>This\ implementation\ translates\ <tt>value</tt>\ to\ a\ string\ with\r\n\ {@link\ Integer\#toString(int)}\ and\ invokes\ {@link\ \#put(String,String)}\r\n\ on\ the\ result.\r\n\r\n\ @param\ key\ key\ with\ which\ the\ string\ form\ of\ value\ is\ to\ be\ associated.\r\n\ @param\ value\ value\ whose\ string\ form\ is\ to\ be\ associated\ with\ key.\r\n\ @throws\ NullPointerException\ if\ key\ is\ <tt>null</tt>.\r\n\ @throws\ IllegalArgumentException\ if\ <tt>key.length()</tt>\ exceeds\r\n\ \ \ \ \ \ \ \ \ <tt>MAX_KEY_LENGTH</tt>.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment7.params=key\ def
comment7.target=int\ getInt(java.lang.String,\ int)
comment7.text=\r\n\ Implements\ the\ <tt>getInt</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#getInt(String,int)}.\r\n\r\n\ <p>This\ implementation\ invokes\ {@link\ \#get(String,String)\ <tt>get(key,\r\n\ null)</tt>}.\ \ If\ the\ return\ value\ is\ non-null,\ the\ implementation\r\n\ attempts\ to\ translate\ it\ to\ an\ <tt>int</tt>\ with\r\n\ {@link\ Integer\#parseInt(String)}.\ \ If\ the\ attempt\ succeeds,\ the\ return\r\n\ value\ is\ returned\ by\ this\ method.\ \ Otherwise,\ <tt>def</tt>\ is\ returned.\r\n\r\n\ @param\ key\ key\ whose\ associated\ value\ is\ to\ be\ returned\ as\ an\ int.\r\n\ @param\ def\ the\ value\ to\ be\ returned\ in\ the\ event\ that\ this\r\n\ \ \ \ \ \ \ \ preference\ node\ has\ no\ value\ associated\ with\ <tt>key</tt>\r\n\ \ \ \ \ \ \ \ or\ the\ associated\ value\ cannot\ be\ interpreted\ as\ an\ int.\r\n\ @return\ the\ int\ value\ represented\ by\ the\ string\ associated\ with\r\n\ \ \ \ \ \ \ \ \ <tt>key</tt>\ in\ this\ preference\ node,\ or\ <tt>def</tt>\ if\ the\r\n\ \ \ \ \ \ \ \ \ associated\ value\ does\ not\ exist\ or\ cannot\ be\ interpreted\ as\r\n\ \ \ \ \ \ \ \ \ an\ int.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @throws\ NullPointerException\ if\ <tt>key</tt>\ is\ <tt>null</tt>.\r\n
comment8.params=key\ value
comment8.target=void\ putLong(java.lang.String,\ long)
comment8.text=\r\n\ Implements\ the\ <tt>putLong</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#putLong(String,long)}.\r\n\r\n\ <p>This\ implementation\ translates\ <tt>value</tt>\ to\ a\ string\ with\r\n\ {@link\ Long\#toString(long)}\ and\ invokes\ {@link\ \#put(String,String)}\r\n\ on\ the\ result.\r\n\r\n\ @param\ key\ key\ with\ which\ the\ string\ form\ of\ value\ is\ to\ be\ associated.\r\n\ @param\ value\ value\ whose\ string\ form\ is\ to\ be\ associated\ with\ key.\r\n\ @throws\ NullPointerException\ if\ key\ is\ <tt>null</tt>.\r\n\ @throws\ IllegalArgumentException\ if\ <tt>key.length()</tt>\ exceeds\r\n\ \ \ \ \ \ \ \ \ <tt>MAX_KEY_LENGTH</tt>.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n
comment9.params=key\ def
comment9.target=long\ getLong(java.lang.String,\ long)
comment9.text=\r\n\ Implements\ the\ <tt>getLong</tt>\ method\ as\ per\ the\ specification\ in\r\n\ {@link\ Preferences\#getLong(String,long)}.\r\n\r\n\ <p>This\ implementation\ invokes\ {@link\ \#get(String,String)\ <tt>get(key,\r\n\ null)</tt>}.\ \ If\ the\ return\ value\ is\ non-null,\ the\ implementation\r\n\ attempts\ to\ translate\ it\ to\ a\ <tt>long</tt>\ with\r\n\ {@link\ Long\#parseLong(String)}.\ \ If\ the\ attempt\ succeeds,\ the\ return\r\n\ value\ is\ returned\ by\ this\ method.\ \ Otherwise,\ <tt>def</tt>\ is\ returned.\r\n\r\n\ @param\ key\ key\ whose\ associated\ value\ is\ to\ be\ returned\ as\ a\ long.\r\n\ @param\ def\ the\ value\ to\ be\ returned\ in\ the\ event\ that\ this\r\n\ \ \ \ \ \ \ \ preference\ node\ has\ no\ value\ associated\ with\ <tt>key</tt>\r\n\ \ \ \ \ \ \ \ or\ the\ associated\ value\ cannot\ be\ interpreted\ as\ a\ long.\r\n\ @return\ the\ long\ value\ represented\ by\ the\ string\ associated\ with\r\n\ \ \ \ \ \ \ \ \ <tt>key</tt>\ in\ this\ preference\ node,\ or\ <tt>def</tt>\ if\ the\r\n\ \ \ \ \ \ \ \ \ associated\ value\ does\ not\ exist\ or\ cannot\ be\ interpreted\ as\r\n\ \ \ \ \ \ \ \ \ a\ long.\r\n\ @throws\ IllegalStateException\ if\ this\ node\ (or\ an\ ancestor)\ has\ been\r\n\ \ \ \ \ \ \ \ \ removed\ with\ the\ {@link\ \#removeNode()}\ method.\r\n\ @throws\ NullPointerException\ if\ <tt>key</tt>\ is\ <tt>null</tt>.\r\n
numComments=60
