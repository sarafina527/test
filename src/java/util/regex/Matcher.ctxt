#BlueJ class context
comment0.target=Matcher
comment0.text=\r\n\ An\ engine\ that\ performs\ match\ operations\ on\ a\ {@link\ java.lang.CharSequence\r\n\ </code>character\ sequence<code>}\ by\ interpreting\ a\ {@link\ Pattern}.\r\n\r\n\ <p>\ A\ matcher\ is\ created\ from\ a\ pattern\ by\ invoking\ the\ pattern's\ {@link\r\n\ Pattern\#matcher\ matcher}\ method.\ \ Once\ created,\ a\ matcher\ can\ be\ used\ to\r\n\ perform\ three\ different\ kinds\ of\ match\ operations\:\r\n\r\n\ <ul>\r\n\r\n\ \ \ <li><p>\ The\ {@link\ \#matches\ matches}\ method\ attempts\ to\ match\ the\ entire\r\n\ \ \ input\ sequence\ against\ the\ pattern.\ \ </p></li>\r\n\r\n\ \ \ <li><p>\ The\ {@link\ \#lookingAt\ lookingAt}\ method\ attempts\ to\ match\ the\r\n\ \ \ input\ sequence,\ starting\ at\ the\ beginning,\ against\ the\ pattern.\ \ </p></li>\r\n\r\n\ \ \ <li><p>\ The\ {@link\ \#find\ find}\ method\ scans\ the\ input\ sequence\ looking\ for\r\n\ \ \ the\ next\ subsequence\ that\ matches\ the\ pattern.\ \ </p></li>\r\n\r\n\ </ul>\r\n\r\n\ <p>\ Each\ of\ these\ methods\ returns\ a\ boolean\ indicating\ success\ or\ failure.\r\n\ More\ information\ about\ a\ successful\ match\ can\ be\ obtained\ by\ querying\ the\r\n\ state\ of\ the\ matcher.\r\n\r\n\ <p>\ A\ matcher\ finds\ matches\ in\ a\ subset\ of\ its\ input\ called\ the\r\n\ <i>region</i>.\ By\ default,\ the\ region\ contains\ all\ of\ the\ matcher's\ input.\r\n\ The\ region\ can\ be\ modified\ via\ the{@link\ \#region\ region}\ method\ and\ queried\r\n\ via\ the\ {@link\ \#regionStart\ regionStart}\ and\ {@link\ \#regionEnd\ regionEnd}\r\n\ methods.\ The\ way\ that\ the\ region\ boundaries\ interact\ with\ some\ pattern\r\n\ constructs\ can\ be\ changed.\ See\ {@link\ \#useAnchoringBounds\r\n\ useAnchoringBounds}\ and\ {@link\ \#useTransparentBounds\ useTransparentBounds}\r\n\ for\ more\ details.\r\n\r\n\ <p>\ This\ class\ also\ defines\ methods\ for\ replacing\ matched\ subsequences\ with\r\n\ new\ strings\ whose\ contents\ can,\ if\ desired,\ be\ computed\ from\ the\ match\r\n\ result.\ \ The\ {@link\ \#appendReplacement\ appendReplacement}\ and\ {@link\r\n\ \#appendTail\ appendTail}\ methods\ can\ be\ used\ in\ tandem\ in\ order\ to\ collect\r\n\ the\ result\ into\ an\ existing\ string\ buffer,\ or\ the\ more\ convenient\ {@link\r\n\ \#replaceAll\ replaceAll}\ method\ can\ be\ used\ to\ create\ a\ string\ in\ which\ every\r\n\ matching\ subsequence\ in\ the\ input\ sequence\ is\ replaced.\r\n\r\n\ <p>\ The\ explicit\ state\ of\ a\ matcher\ includes\ the\ start\ and\ end\ indices\ of\r\n\ the\ most\ recent\ successful\ match.\ \ It\ also\ includes\ the\ start\ and\ end\r\n\ indices\ of\ the\ input\ subsequence\ captured\ by\ each\ <a\r\n\ href\="Pattern.html\#cg">capturing\ group</a>\ in\ the\ pattern\ as\ well\ as\ a\ total\r\n\ count\ of\ such\ subsequences.\ \ As\ a\ convenience,\ methods\ are\ also\ provided\ for\r\n\ returning\ these\ captured\ subsequences\ in\ string\ form.\r\n\r\n\ <p>\ The\ explicit\ state\ of\ a\ matcher\ is\ initially\ undefined;\ attempting\ to\r\n\ query\ any\ part\ of\ it\ before\ a\ successful\ match\ will\ cause\ an\ {@link\r\n\ IllegalStateException}\ to\ be\ thrown.\ \ The\ explicit\ state\ of\ a\ matcher\ is\r\n\ recomputed\ by\ every\ match\ operation.\r\n\r\n\ <p>\ The\ implicit\ state\ of\ a\ matcher\ includes\ the\ input\ character\ sequence\ as\r\n\ well\ as\ the\ <i>append\ position</i>,\ which\ is\ initially\ zero\ and\ is\ updated\r\n\ by\ the\ {@link\ \#appendReplacement\ appendReplacement}\ method.\r\n\r\n\ <p>\ A\ matcher\ may\ be\ reset\ explicitly\ by\ invoking\ its\ {@link\ \#reset()}\r\n\ method\ or,\ if\ a\ new\ input\ sequence\ is\ desired,\ its\ {@link\r\n\ \#reset(java.lang.CharSequence)\ reset(CharSequence)}\ method.\ \ Resetting\ a\r\n\ matcher\ discards\ its\ explicit\ state\ information\ and\ sets\ the\ append\ position\r\n\ to\ zero.\r\n\r\n\ <p>\ Instances\ of\ this\ class\ are\ not\ safe\ for\ use\ by\ multiple\ concurrent\r\n\ threads.\ </p>\r\n\r\n\r\n\ @author\ \ \ \ \ \ Mike\ McCloskey\r\n\ @author\ \ \ \ \ \ Mark\ Reinhold\r\n\ @author\ \ \ \ \ \ JSR-51\ Expert\ Group\r\n\ @since\ \ \ \ \ \ \ 1.4\r\n\ @spec\ \ \ \ \ \ \ \ JSR-51\r\n
comment1.params=
comment1.target=Matcher()
comment1.text=\r\n\ No\ default\ constructor.\r\n
comment10.params=
comment10.target=int\ end()
comment10.text=\r\n\ Returns\ the\ offset\ after\ the\ last\ character\ matched.\ \ </p>\r\n\r\n\ @return\ \ The\ offset\ after\ the\ last\ character\ matched\r\n\r\n\ @throws\ \ IllegalStateException\r\n\ \ \ \ \ \ \ \ \ \ If\ no\ match\ has\ yet\ been\ attempted,\r\n\ \ \ \ \ \ \ \ \ \ or\ if\ the\ previous\ match\ operation\ failed\r\n
comment11.params=group
comment11.target=int\ end(int)
comment11.text=\r\n\ Returns\ the\ offset\ after\ the\ last\ character\ of\ the\ subsequence\r\n\ captured\ by\ the\ given\ group\ during\ the\ previous\ match\ operation.\r\n\r\n\ <p>\ <a\ href\="Pattern.html\#cg">Capturing\ groups</a>\ are\ indexed\ from\ left\r\n\ to\ right,\ starting\ at\ one.\ \ Group\ zero\ denotes\ the\ entire\ pattern,\ so\r\n\ the\ expression\ <i>m.</i><tt>end(0)</tt>\ is\ equivalent\ to\r\n\ <i>m.</i><tt>end()</tt>.\ \ </p>\r\n\r\n\ @param\ \ group\r\n\ \ \ \ \ \ \ \ \ The\ index\ of\ a\ capturing\ group\ in\ this\ matcher's\ pattern\r\n\r\n\ @return\ \ The\ offset\ after\ the\ last\ character\ captured\ by\ the\ group,\r\n\ \ \ \ \ \ \ \ \ \ or\ <tt>-1</tt>\ if\ the\ match\ was\ successful\r\n\ \ \ \ \ \ \ \ \ \ but\ the\ group\ itself\ did\ not\ match\ anything\r\n\r\n\ @throws\ \ IllegalStateException\r\n\ \ \ \ \ \ \ \ \ \ If\ no\ match\ has\ yet\ been\ attempted,\r\n\ \ \ \ \ \ \ \ \ \ or\ if\ the\ previous\ match\ operation\ failed\r\n\r\n\ @throws\ \ IndexOutOfBoundsException\r\n\ \ \ \ \ \ \ \ \ \ If\ there\ is\ no\ capturing\ group\ in\ the\ pattern\r\n\ \ \ \ \ \ \ \ \ \ with\ the\ given\ index\r\n
comment12.params=
comment12.target=java.lang.String\ group()
comment12.text=\r\n\ Returns\ the\ input\ subsequence\ matched\ by\ the\ previous\ match.\r\n\r\n\ <p>\ For\ a\ matcher\ <i>m</i>\ with\ input\ sequence\ <i>s</i>,\r\n\ the\ expressions\ <i>m.</i><tt>group()</tt>\ and\r\n\ <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(),</tt>&nbsp;<i>m.</i><tt>end())</tt>\r\n\ are\ equivalent.\ \ </p>\r\n\r\n\ <p>\ Note\ that\ some\ patterns,\ for\ example\ <tt>a*</tt>,\ match\ the\ empty\r\n\ string.\ \ This\ method\ will\ return\ the\ empty\ string\ when\ the\ pattern\r\n\ successfully\ matches\ the\ empty\ string\ in\ the\ input.\ \ </p>\r\n\r\n\ @return\ The\ (possibly\ empty)\ subsequence\ matched\ by\ the\ previous\ match,\r\n\ \ \ \ \ \ \ \ \ in\ string\ form\r\n\r\n\ @throws\ \ IllegalStateException\r\n\ \ \ \ \ \ \ \ \ \ If\ no\ match\ has\ yet\ been\ attempted,\r\n\ \ \ \ \ \ \ \ \ \ or\ if\ the\ previous\ match\ operation\ failed\r\n
comment13.params=group
comment13.target=java.lang.String\ group(int)
comment13.text=\r\n\ Returns\ the\ input\ subsequence\ captured\ by\ the\ given\ group\ during\ the\r\n\ previous\ match\ operation.\r\n\r\n\ <p>\ For\ a\ matcher\ <i>m</i>,\ input\ sequence\ <i>s</i>,\ and\ group\ index\r\n\ <i>g</i>,\ the\ expressions\ <i>m.</i><tt>group(</tt><i>g</i><tt>)</tt>\ and\r\n\ <i>s.</i><tt>substring(</tt><i>m.</i><tt>start(</tt><i>g</i><tt>),</tt>&nbsp;<i>m.</i><tt>end(</tt><i>g</i><tt>))</tt>\r\n\ are\ equivalent.\ \ </p>\r\n\r\n\ <p>\ <a\ href\="Pattern.html\#cg">Capturing\ groups</a>\ are\ indexed\ from\ left\r\n\ to\ right,\ starting\ at\ one.\ \ Group\ zero\ denotes\ the\ entire\ pattern,\ so\r\n\ the\ expression\ <tt>m.group(0)</tt>\ is\ equivalent\ to\ <tt>m.group()</tt>.\r\n\ </p>\r\n\r\n\ <p>\ If\ the\ match\ was\ successful\ but\ the\ group\ specified\ failed\ to\ match\r\n\ any\ part\ of\ the\ input\ sequence,\ then\ <tt>null</tt>\ is\ returned.\ Note\r\n\ that\ some\ groups,\ for\ example\ <tt>(a*)</tt>,\ match\ the\ empty\ string.\r\n\ This\ method\ will\ return\ the\ empty\ string\ when\ such\ a\ group\ successfully\r\n\ matches\ the\ empty\ string\ in\ the\ input.\ \ </p>\r\n\r\n\ @param\ \ group\r\n\ \ \ \ \ \ \ \ \ The\ index\ of\ a\ capturing\ group\ in\ this\ matcher's\ pattern\r\n\r\n\ @return\ \ The\ (possibly\ empty)\ subsequence\ captured\ by\ the\ group\r\n\ \ \ \ \ \ \ \ \ \ during\ the\ previous\ match,\ or\ <tt>null</tt>\ if\ the\ group\r\n\ \ \ \ \ \ \ \ \ \ failed\ to\ match\ part\ of\ the\ input\r\n\r\n\ @throws\ \ IllegalStateException\r\n\ \ \ \ \ \ \ \ \ \ If\ no\ match\ has\ yet\ been\ attempted,\r\n\ \ \ \ \ \ \ \ \ \ or\ if\ the\ previous\ match\ operation\ failed\r\n\r\n\ @throws\ \ IndexOutOfBoundsException\r\n\ \ \ \ \ \ \ \ \ \ If\ there\ is\ no\ capturing\ group\ in\ the\ pattern\r\n\ \ \ \ \ \ \ \ \ \ with\ the\ given\ index\r\n
comment14.params=name
comment14.target=java.lang.String\ group(java.lang.String)
comment14.text=\r\n\ Returns\ the\ input\ subsequence\ captured\ by\ the\ given\r\n\ <a\ href\="Pattern.html\#groupname">named-capturing\ group</a>\ during\ the\ previous\r\n\ match\ operation.\r\n\r\n\ <p>\ If\ the\ match\ was\ successful\ but\ the\ group\ specified\ failed\ to\ match\r\n\ any\ part\ of\ the\ input\ sequence,\ then\ <tt>null</tt>\ is\ returned.\ Note\r\n\ that\ some\ groups,\ for\ example\ <tt>(a*)</tt>,\ match\ the\ empty\ string.\r\n\ This\ method\ will\ return\ the\ empty\ string\ when\ such\ a\ group\ successfully\r\n\ matches\ the\ empty\ string\ in\ the\ input.\ \ </p>\r\n\r\n\ @param\ \ name\r\n\ \ \ \ \ \ \ \ \ The\ name\ of\ a\ named-capturing\ group\ in\ this\ matcher's\ pattern\r\n\r\n\ @return\ \ The\ (possibly\ empty)\ subsequence\ captured\ by\ the\ named\ group\r\n\ \ \ \ \ \ \ \ \ \ during\ the\ previous\ match,\ or\ <tt>null</tt>\ if\ the\ group\r\n\ \ \ \ \ \ \ \ \ \ failed\ to\ match\ part\ of\ the\ input\r\n\r\n\ @throws\ \ IllegalStateException\r\n\ \ \ \ \ \ \ \ \ \ If\ no\ match\ has\ yet\ been\ attempted,\r\n\ \ \ \ \ \ \ \ \ \ or\ if\ the\ previous\ match\ operation\ failed\r\n\r\n\ @throws\ \ IllegalArgumentException\r\n\ \ \ \ \ \ \ \ \ \ If\ there\ is\ no\ capturing\ group\ in\ the\ pattern\r\n\ \ \ \ \ \ \ \ \ \ with\ the\ given\ name\r\n\ @since\ 1.7\r\n
comment15.params=
comment15.target=int\ groupCount()
comment15.text=\r\n\ Returns\ the\ number\ of\ capturing\ groups\ in\ this\ matcher's\ pattern.\r\n\r\n\ <p>\ Group\ zero\ denotes\ the\ entire\ pattern\ by\ convention.\ It\ is\ not\r\n\ included\ in\ this\ count.\r\n\r\n\ <p>\ Any\ non-negative\ integer\ smaller\ than\ or\ equal\ to\ the\ value\r\n\ returned\ by\ this\ method\ is\ guaranteed\ to\ be\ a\ valid\ group\ index\ for\r\n\ this\ matcher.\ \ </p>\r\n\r\n\ @return\ The\ number\ of\ capturing\ groups\ in\ this\ matcher's\ pattern\r\n
comment16.params=
comment16.target=boolean\ matches()
comment16.text=\r\n\ Attempts\ to\ match\ the\ entire\ region\ against\ the\ pattern.\r\n\r\n\ <p>\ If\ the\ match\ succeeds\ then\ more\ information\ can\ be\ obtained\ via\ the\r\n\ <tt>start</tt>,\ <tt>end</tt>,\ and\ <tt>group</tt>\ methods.\ \ </p>\r\n\r\n\ @return\ \ <tt>true</tt>\ if,\ and\ only\ if,\ the\ entire\ region\ sequence\r\n\ \ \ \ \ \ \ \ \ \ matches\ this\ matcher's\ pattern\r\n
comment17.params=
comment17.target=boolean\ find()
comment17.text=\r\n\ Attempts\ to\ find\ the\ next\ subsequence\ of\ the\ input\ sequence\ that\ matches\r\n\ the\ pattern.\r\n\r\n\ <p>\ This\ method\ starts\ at\ the\ beginning\ of\ this\ matcher's\ region,\ or,\ if\r\n\ a\ previous\ invocation\ of\ the\ method\ was\ successful\ and\ the\ matcher\ has\r\n\ not\ since\ been\ reset,\ at\ the\ first\ character\ not\ matched\ by\ the\ previous\r\n\ match.\r\n\r\n\ <p>\ If\ the\ match\ succeeds\ then\ more\ information\ can\ be\ obtained\ via\ the\r\n\ <tt>start</tt>,\ <tt>end</tt>,\ and\ <tt>group</tt>\ methods.\ \ </p>\r\n\r\n\ @return\ \ <tt>true</tt>\ if,\ and\ only\ if,\ a\ subsequence\ of\ the\ input\r\n\ \ \ \ \ \ \ \ \ \ sequence\ matches\ this\ matcher's\ pattern\r\n
comment18.params=start
comment18.target=boolean\ find(int)
comment18.text=\r\n\ Resets\ this\ matcher\ and\ then\ attempts\ to\ find\ the\ next\ subsequence\ of\r\n\ the\ input\ sequence\ that\ matches\ the\ pattern,\ starting\ at\ the\ specified\r\n\ index.\r\n\r\n\ <p>\ If\ the\ match\ succeeds\ then\ more\ information\ can\ be\ obtained\ via\ the\r\n\ <tt>start</tt>,\ <tt>end</tt>,\ and\ <tt>group</tt>\ methods,\ and\ subsequent\r\n\ invocations\ of\ the\ {@link\ \#find()}\ method\ will\ start\ at\ the\ first\r\n\ character\ not\ matched\ by\ this\ match.\ \ </p>\r\n\r\n\ @throws\ \ IndexOutOfBoundsException\r\n\ \ \ \ \ \ \ \ \ \ If\ start\ is\ less\ than\ zero\ or\ if\ start\ is\ greater\ than\ the\r\n\ \ \ \ \ \ \ \ \ \ length\ of\ the\ input\ sequence.\r\n\r\n\ @return\ \ <tt>true</tt>\ if,\ and\ only\ if,\ a\ subsequence\ of\ the\ input\r\n\ \ \ \ \ \ \ \ \ \ sequence\ starting\ at\ the\ given\ index\ matches\ this\ matcher's\r\n\ \ \ \ \ \ \ \ \ \ pattern\r\n
comment19.params=
comment19.target=boolean\ lookingAt()
comment19.text=\r\n\ Attempts\ to\ match\ the\ input\ sequence,\ starting\ at\ the\ beginning\ of\ the\r\n\ region,\ against\ the\ pattern.\r\n\r\n\ <p>\ Like\ the\ {@link\ \#matches\ matches}\ method,\ this\ method\ always\ starts\r\n\ at\ the\ beginning\ of\ the\ region;\ unlike\ that\ method,\ it\ does\ not\r\n\ require\ that\ the\ entire\ region\ be\ matched.\r\n\r\n\ <p>\ If\ the\ match\ succeeds\ then\ more\ information\ can\ be\ obtained\ via\ the\r\n\ <tt>start</tt>,\ <tt>end</tt>,\ and\ <tt>group</tt>\ methods.\ \ </p>\r\n\r\n\ @return\ \ <tt>true</tt>\ if,\ and\ only\ if,\ a\ prefix\ of\ the\ input\r\n\ \ \ \ \ \ \ \ \ \ sequence\ matches\ this\ matcher's\ pattern\r\n
comment2.params=parent\ text
comment2.target=Matcher(java.util.regex.Pattern,\ java.lang.CharSequence)
comment2.text=\r\n\ All\ matchers\ have\ the\ state\ used\ by\ Pattern\ during\ a\ match.\r\n
comment20.params=s
comment20.target=java.lang.String\ quoteReplacement(java.lang.String)
comment20.text=\r\n\ Returns\ a\ literal\ replacement\ <code>String</code>\ for\ the\ specified\r\n\ <code>String</code>.\r\n\r\n\ This\ method\ produces\ a\ <code>String</code>\ that\ will\ work\r\n\ as\ a\ literal\ replacement\ <code>s</code>\ in\ the\r\n\ <code>appendReplacement</code>\ method\ of\ the\ {@link\ Matcher}\ class.\r\n\ The\ <code>String</code>\ produced\ will\ match\ the\ sequence\ of\ characters\r\n\ in\ <code>s</code>\ treated\ as\ a\ literal\ sequence.\ Slashes\ ('\\')\ and\r\n\ dollar\ signs\ ('$')\ will\ be\ given\ no\ special\ meaning.\r\n\r\n\ @param\ \ s\ The\ string\ to\ be\ literalized\r\n\ @return\ \ A\ literal\ string\ replacement\r\n\ @since\ 1.5\r\n
comment21.params=sb\ replacement
comment21.target=java.util.regex.Matcher\ appendReplacement(java.lang.StringBuffer,\ java.lang.String)
comment21.text=\r\n\ Implements\ a\ non-terminal\ append-and-replace\ step.\r\n\r\n\ <p>\ This\ method\ performs\ the\ following\ actions\:\ </p>\r\n\r\n\ <ol>\r\n\r\n\ \ \ <li><p>\ It\ reads\ characters\ from\ the\ input\ sequence,\ starting\ at\ the\r\n\ \ \ append\ position,\ and\ appends\ them\ to\ the\ given\ string\ buffer.\ \ It\r\n\ \ \ stops\ after\ reading\ the\ last\ character\ preceding\ the\ previous\ match,\r\n\ \ \ that\ is,\ the\ character\ at\ index\ {@link\r\n\ \ \ \#start()}&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>.\ \ </p></li>\r\n\r\n\ \ \ <li><p>\ It\ appends\ the\ given\ replacement\ string\ to\ the\ string\ buffer.\r\n\ \ \ </p></li>\r\n\r\n\ \ \ <li><p>\ It\ sets\ the\ append\ position\ of\ this\ matcher\ to\ the\ index\ of\r\n\ \ \ the\ last\ character\ matched,\ plus\ one,\ that\ is,\ to\ {@link\ \#end()}.\r\n\ \ \ </p></li>\r\n\r\n\ </ol>\r\n\r\n\ <p>\ The\ replacement\ string\ may\ contain\ references\ to\ subsequences\r\n\ captured\ during\ the\ previous\ match\:\ Each\ occurrence\ of\r\n\ <tt>${</tt><i>name</i><tt>}</tt>\ or\ <tt>$</tt><i>g</i>\r\n\ will\ be\ replaced\ by\ the\ result\ of\ evaluating\ the\ corresponding\r\n\ {@link\ \#group(String)\ group(name)}\ or\ {@link\ \#group(int)\ group(g)</tt>}\r\n\ respectively.\ For\ \ <tt>$</tt><i>g</i><tt></tt>,\r\n\ the\ first\ number\ after\ the\ <tt>$</tt>\ is\ always\ treated\ as\ part\ of\r\n\ the\ group\ reference.\ Subsequent\ numbers\ are\ incorporated\ into\ g\ if\r\n\ they\ would\ form\ a\ legal\ group\ reference.\ Only\ the\ numerals\ '0'\r\n\ through\ '9'\ are\ considered\ as\ potential\ components\ of\ the\ group\r\n\ reference.\ If\ the\ second\ group\ matched\ the\ string\ <tt>"foo"</tt>,\ for\r\n\ example,\ then\ passing\ the\ replacement\ string\ <tt>"$2bar"</tt>\ would\r\n\ cause\ <tt>"foobar"</tt>\ to\ be\ appended\ to\ the\ string\ buffer.\ A\ dollar\r\n\ sign\ (<tt>$</tt>)\ may\ be\ included\ as\ a\ literal\ in\ the\ replacement\r\n\ string\ by\ preceding\ it\ with\ a\ backslash\ (<tt>\\$</tt>).\r\n\r\n\ <p>\ Note\ that\ backslashes\ (<tt>\\</tt>)\ and\ dollar\ signs\ (<tt>$</tt>)\ in\r\n\ the\ replacement\ string\ may\ cause\ the\ results\ to\ be\ different\ than\ if\ it\r\n\ were\ being\ treated\ as\ a\ literal\ replacement\ string.\ Dollar\ signs\ may\ be\r\n\ treated\ as\ references\ to\ captured\ subsequences\ as\ described\ above,\ and\r\n\ backslashes\ are\ used\ to\ escape\ literal\ characters\ in\ the\ replacement\r\n\ string.\r\n\r\n\ <p>\ This\ method\ is\ intended\ to\ be\ used\ in\ a\ loop\ together\ with\ the\r\n\ {@link\ \#appendTail\ appendTail}\ and\ {@link\ \#find\ find}\ methods.\ \ The\r\n\ following\ code,\ for\ example,\ writes\ <tt>one\ dog\ two\ dogs\ in\ the\r\n\ yard</tt>\ to\ the\ standard-output\ stream\:\ </p>\r\n\r\n\ <blockquote><pre>\r\n\ Pattern\ p\ \=\ Pattern.compile("cat");\r\n\ Matcher\ m\ \=\ p.matcher("one\ cat\ two\ cats\ in\ the\ yard");\r\n\ StringBuffer\ sb\ \=\ new\ StringBuffer();\r\n\ while\ (m.find())\ {\r\n\ \ \ \ \ m.appendReplacement(sb,\ "dog");\r\n\ }\r\n\ m.appendTail(sb);\r\n\ System.out.println(sb.toString());</pre></blockquote>\r\n\r\n\ @param\ \ sb\r\n\ \ \ \ \ \ \ \ \ The\ target\ string\ buffer\r\n\r\n\ @param\ \ replacement\r\n\ \ \ \ \ \ \ \ \ The\ replacement\ string\r\n\r\n\ @return\ \ This\ matcher\r\n\r\n\ @throws\ \ IllegalStateException\r\n\ \ \ \ \ \ \ \ \ \ If\ no\ match\ has\ yet\ been\ attempted,\r\n\ \ \ \ \ \ \ \ \ \ or\ if\ the\ previous\ match\ operation\ failed\r\n\r\n\ @throws\ \ IllegalArgumentException\r\n\ \ \ \ \ \ \ \ \ \ If\ the\ replacement\ string\ refers\ to\ a\ named-capturing\r\n\ \ \ \ \ \ \ \ \ \ group\ that\ does\ not\ exist\ in\ the\ pattern\r\n\r\n\ @throws\ \ IndexOutOfBoundsException\r\n\ \ \ \ \ \ \ \ \ \ If\ the\ replacement\ string\ refers\ to\ a\ capturing\ group\r\n\ \ \ \ \ \ \ \ \ \ that\ does\ not\ exist\ in\ the\ pattern\r\n
comment22.params=sb
comment22.target=java.lang.StringBuffer\ appendTail(java.lang.StringBuffer)
comment22.text=\r\n\ Implements\ a\ terminal\ append-and-replace\ step.\r\n\r\n\ <p>\ This\ method\ reads\ characters\ from\ the\ input\ sequence,\ starting\ at\r\n\ the\ append\ position,\ and\ appends\ them\ to\ the\ given\ string\ buffer.\ \ It\ is\r\n\ intended\ to\ be\ invoked\ after\ one\ or\ more\ invocations\ of\ the\ {@link\r\n\ \#appendReplacement\ appendReplacement}\ method\ in\ order\ to\ copy\ the\r\n\ remainder\ of\ the\ input\ sequence.\ \ </p>\r\n\r\n\ @param\ \ sb\r\n\ \ \ \ \ \ \ \ \ The\ target\ string\ buffer\r\n\r\n\ @return\ \ The\ target\ string\ buffer\r\n
comment23.params=replacement
comment23.target=java.lang.String\ replaceAll(java.lang.String)
comment23.text=\r\n\ Replaces\ every\ subsequence\ of\ the\ input\ sequence\ that\ matches\ the\r\n\ pattern\ with\ the\ given\ replacement\ string.\r\n\r\n\ <p>\ This\ method\ first\ resets\ this\ matcher.\ \ It\ then\ scans\ the\ input\r\n\ sequence\ looking\ for\ matches\ of\ the\ pattern.\ \ Characters\ that\ are\ not\r\n\ part\ of\ any\ match\ are\ appended\ directly\ to\ the\ result\ string;\ each\ match\r\n\ is\ replaced\ in\ the\ result\ by\ the\ replacement\ string.\ \ The\ replacement\r\n\ string\ may\ contain\ references\ to\ captured\ subsequences\ as\ in\ the\ {@link\r\n\ \#appendReplacement\ appendReplacement}\ method.\r\n\r\n\ <p>\ Note\ that\ backslashes\ (<tt>\\</tt>)\ and\ dollar\ signs\ (<tt>$</tt>)\ in\r\n\ the\ replacement\ string\ may\ cause\ the\ results\ to\ be\ different\ than\ if\ it\r\n\ were\ being\ treated\ as\ a\ literal\ replacement\ string.\ Dollar\ signs\ may\ be\r\n\ treated\ as\ references\ to\ captured\ subsequences\ as\ described\ above,\ and\r\n\ backslashes\ are\ used\ to\ escape\ literal\ characters\ in\ the\ replacement\r\n\ string.\r\n\r\n\ <p>\ Given\ the\ regular\ expression\ <tt>a*b</tt>,\ the\ input\r\n\ <tt>"aabfooaabfooabfoob"</tt>,\ and\ the\ replacement\ string\r\n\ <tt>"-"</tt>,\ an\ invocation\ of\ this\ method\ on\ a\ matcher\ for\ that\r\n\ expression\ would\ yield\ the\ string\ <tt>"-foo-foo-foo-"</tt>.\r\n\r\n\ <p>\ Invoking\ this\ method\ changes\ this\ matcher's\ state.\ \ If\ the\ matcher\r\n\ is\ to\ be\ used\ in\ further\ matching\ operations\ then\ it\ should\ first\ be\r\n\ reset.\ \ </p>\r\n\r\n\ @param\ \ replacement\r\n\ \ \ \ \ \ \ \ \ The\ replacement\ string\r\n\r\n\ @return\ \ The\ string\ constructed\ by\ replacing\ each\ matching\ subsequence\r\n\ \ \ \ \ \ \ \ \ \ by\ the\ replacement\ string,\ substituting\ captured\ subsequences\r\n\ \ \ \ \ \ \ \ \ \ as\ needed\r\n
comment24.params=replacement
comment24.target=java.lang.String\ replaceFirst(java.lang.String)
comment24.text=\r\n\ Replaces\ the\ first\ subsequence\ of\ the\ input\ sequence\ that\ matches\ the\r\n\ pattern\ with\ the\ given\ replacement\ string.\r\n\r\n\ <p>\ This\ method\ first\ resets\ this\ matcher.\ \ It\ then\ scans\ the\ input\r\n\ sequence\ looking\ for\ a\ match\ of\ the\ pattern.\ \ Characters\ that\ are\ not\r\n\ part\ of\ the\ match\ are\ appended\ directly\ to\ the\ result\ string;\ the\ match\r\n\ is\ replaced\ in\ the\ result\ by\ the\ replacement\ string.\ \ The\ replacement\r\n\ string\ may\ contain\ references\ to\ captured\ subsequences\ as\ in\ the\ {@link\r\n\ \#appendReplacement\ appendReplacement}\ method.\r\n\r\n\ <p>Note\ that\ backslashes\ (<tt>\\</tt>)\ and\ dollar\ signs\ (<tt>$</tt>)\ in\r\n\ the\ replacement\ string\ may\ cause\ the\ results\ to\ be\ different\ than\ if\ it\r\n\ were\ being\ treated\ as\ a\ literal\ replacement\ string.\ Dollar\ signs\ may\ be\r\n\ treated\ as\ references\ to\ captured\ subsequences\ as\ described\ above,\ and\r\n\ backslashes\ are\ used\ to\ escape\ literal\ characters\ in\ the\ replacement\r\n\ string.\r\n\r\n\ <p>\ Given\ the\ regular\ expression\ <tt>dog</tt>,\ the\ input\r\n\ <tt>"zzzdogzzzdogzzz"</tt>,\ and\ the\ replacement\ string\r\n\ <tt>"cat"</tt>,\ an\ invocation\ of\ this\ method\ on\ a\ matcher\ for\ that\r\n\ expression\ would\ yield\ the\ string\ <tt>"zzzcatzzzdogzzz"</tt>.\ \ </p>\r\n\r\n\ <p>\ Invoking\ this\ method\ changes\ this\ matcher's\ state.\ \ If\ the\ matcher\r\n\ is\ to\ be\ used\ in\ further\ matching\ operations\ then\ it\ should\ first\ be\r\n\ reset.\ \ </p>\r\n\r\n\ @param\ \ replacement\r\n\ \ \ \ \ \ \ \ \ The\ replacement\ string\r\n\ @return\ \ The\ string\ constructed\ by\ replacing\ the\ first\ matching\r\n\ \ \ \ \ \ \ \ \ \ subsequence\ by\ the\ replacement\ string,\ substituting\ captured\r\n\ \ \ \ \ \ \ \ \ \ subsequences\ as\ needed\r\n
comment25.params=start\ end
comment25.target=java.util.regex.Matcher\ region(int,\ int)
comment25.text=\r\n\ Sets\ the\ limits\ of\ this\ matcher's\ region.\ The\ region\ is\ the\ part\ of\ the\r\n\ input\ sequence\ that\ will\ be\ searched\ to\ find\ a\ match.\ Invoking\ this\r\n\ method\ resets\ the\ matcher,\ and\ then\ sets\ the\ region\ to\ start\ at\ the\r\n\ index\ specified\ by\ the\ <code>start</code>\ parameter\ and\ end\ at\ the\r\n\ index\ specified\ by\ the\ <code>end</code>\ parameter.\r\n\r\n\ <p>Depending\ on\ the\ transparency\ and\ anchoring\ being\ used\ (see\r\n\ {@link\ \#useTransparentBounds\ useTransparentBounds}\ and\r\n\ {@link\ \#useAnchoringBounds\ useAnchoringBounds}),\ certain\ constructs\ such\r\n\ as\ anchors\ may\ behave\ differently\ at\ or\ around\ the\ boundaries\ of\ the\r\n\ region.\r\n\r\n\ @param\ \ start\r\n\ \ \ \ \ \ \ \ \ The\ index\ to\ start\ searching\ at\ (inclusive)\r\n\ @param\ \ end\r\n\ \ \ \ \ \ \ \ \ The\ index\ to\ end\ searching\ at\ (exclusive)\r\n\ @throws\ \ IndexOutOfBoundsException\r\n\ \ \ \ \ \ \ \ \ \ If\ start\ or\ end\ is\ less\ than\ zero,\ if\r\n\ \ \ \ \ \ \ \ \ \ start\ is\ greater\ than\ the\ length\ of\ the\ input\ sequence,\ if\r\n\ \ \ \ \ \ \ \ \ \ end\ is\ greater\ than\ the\ length\ of\ the\ input\ sequence,\ or\ if\r\n\ \ \ \ \ \ \ \ \ \ start\ is\ greater\ than\ end.\r\n\ @return\ \ this\ matcher\r\n\ @since\ 1.5\r\n
comment26.params=
comment26.target=int\ regionStart()
comment26.text=\r\n\ Reports\ the\ start\ index\ of\ this\ matcher's\ region.\ The\r\n\ searches\ this\ matcher\ conducts\ are\ limited\ to\ finding\ matches\r\n\ within\ {@link\ \#regionStart\ regionStart}\ (inclusive)\ and\r\n\ {@link\ \#regionEnd\ regionEnd}\ (exclusive).\r\n\r\n\ @return\ \ The\ starting\ point\ of\ this\ matcher's\ region\r\n\ @since\ 1.5\r\n
comment27.params=
comment27.target=int\ regionEnd()
comment27.text=\r\n\ Reports\ the\ end\ index\ (exclusive)\ of\ this\ matcher's\ region.\r\n\ The\ searches\ this\ matcher\ conducts\ are\ limited\ to\ finding\ matches\r\n\ within\ {@link\ \#regionStart\ regionStart}\ (inclusive)\ and\r\n\ {@link\ \#regionEnd\ regionEnd}\ (exclusive).\r\n\r\n\ @return\ \ the\ ending\ point\ of\ this\ matcher's\ region\r\n\ @since\ 1.5\r\n
comment28.params=
comment28.target=boolean\ hasTransparentBounds()
comment28.text=\r\n\ Queries\ the\ transparency\ of\ region\ bounds\ for\ this\ matcher.\r\n\r\n\ <p>\ This\ method\ returns\ <tt>true</tt>\ if\ this\ matcher\ uses\r\n\ <i>transparent</i>\ bounds,\ <tt>false</tt>\ if\ it\ uses\ <i>opaque</i>\r\n\ bounds.\r\n\r\n\ <p>\ See\ {@link\ \#useTransparentBounds\ useTransparentBounds}\ for\ a\r\n\ description\ of\ transparent\ and\ opaque\ bounds.\r\n\r\n\ <p>\ By\ default,\ a\ matcher\ uses\ opaque\ region\ boundaries.\r\n\r\n\ @return\ <tt>true</tt>\ iff\ this\ matcher\ is\ using\ transparent\ bounds,\r\n\ \ \ \ \ \ \ \ \ <tt>false</tt>\ otherwise.\r\n\ @see\ java.util.regex.Matcher\#useTransparentBounds(boolean)\r\n\ @since\ 1.5\r\n
comment29.params=b
comment29.target=java.util.regex.Matcher\ useTransparentBounds(boolean)
comment29.text=\r\n\ Sets\ the\ transparency\ of\ region\ bounds\ for\ this\ matcher.\r\n\r\n\ <p>\ Invoking\ this\ method\ with\ an\ argument\ of\ <tt>true</tt>\ will\ set\ this\r\n\ matcher\ to\ use\ <i>transparent</i>\ bounds.\ If\ the\ boolean\r\n\ argument\ is\ <tt>false</tt>,\ then\ <i>opaque</i>\ bounds\ will\ be\ used.\r\n\r\n\ <p>\ Using\ transparent\ bounds,\ the\ boundaries\ of\ this\r\n\ matcher's\ region\ are\ transparent\ to\ lookahead,\ lookbehind,\r\n\ and\ boundary\ matching\ constructs.\ Those\ constructs\ can\ see\ beyond\ the\r\n\ boundaries\ of\ the\ region\ to\ see\ if\ a\ match\ is\ appropriate.\r\n\r\n\ <p>\ Using\ opaque\ bounds,\ the\ boundaries\ of\ this\ matcher's\r\n\ region\ are\ opaque\ to\ lookahead,\ lookbehind,\ and\ boundary\ matching\r\n\ constructs\ that\ may\ try\ to\ see\ beyond\ them.\ Those\ constructs\ cannot\r\n\ look\ past\ the\ boundaries\ so\ they\ will\ fail\ to\ match\ anything\ outside\r\n\ of\ the\ region.\r\n\r\n\ <p>\ By\ default,\ a\ matcher\ uses\ opaque\ bounds.\r\n\r\n\ @param\ \ b\ a\ boolean\ indicating\ whether\ to\ use\ opaque\ or\ transparent\r\n\ \ \ \ \ \ \ \ \ regions\r\n\ @return\ this\ matcher\r\n\ @see\ java.util.regex.Matcher\#hasTransparentBounds\r\n\ @since\ 1.5\r\n
comment3.params=
comment3.target=java.util.regex.Pattern\ pattern()
comment3.text=\r\n\ Returns\ the\ pattern\ that\ is\ interpreted\ by\ this\ matcher.\r\n\r\n\ @return\ \ The\ pattern\ for\ which\ this\ matcher\ was\ created\r\n
comment30.params=
comment30.target=boolean\ hasAnchoringBounds()
comment30.text=\r\n\ Queries\ the\ anchoring\ of\ region\ bounds\ for\ this\ matcher.\r\n\r\n\ <p>\ This\ method\ returns\ <tt>true</tt>\ if\ this\ matcher\ uses\r\n\ <i>anchoring</i>\ bounds,\ <tt>false</tt>\ otherwise.\r\n\r\n\ <p>\ See\ {@link\ \#useAnchoringBounds\ useAnchoringBounds}\ for\ a\r\n\ description\ of\ anchoring\ bounds.\r\n\r\n\ <p>\ By\ default,\ a\ matcher\ uses\ anchoring\ region\ boundaries.\r\n\r\n\ @return\ <tt>true</tt>\ iff\ this\ matcher\ is\ using\ anchoring\ bounds,\r\n\ \ \ \ \ \ \ \ \ <tt>false</tt>\ otherwise.\r\n\ @see\ java.util.regex.Matcher\#useAnchoringBounds(boolean)\r\n\ @since\ 1.5\r\n
comment31.params=b
comment31.target=java.util.regex.Matcher\ useAnchoringBounds(boolean)
comment31.text=\r\n\ Sets\ the\ anchoring\ of\ region\ bounds\ for\ this\ matcher.\r\n\r\n\ <p>\ Invoking\ this\ method\ with\ an\ argument\ of\ <tt>true</tt>\ will\ set\ this\r\n\ matcher\ to\ use\ <i>anchoring</i>\ bounds.\ If\ the\ boolean\r\n\ argument\ is\ <tt>false</tt>,\ then\ <i>non-anchoring</i>\ bounds\ will\ be\r\n\ used.\r\n\r\n\ <p>\ Using\ anchoring\ bounds,\ the\ boundaries\ of\ this\r\n\ matcher's\ region\ match\ anchors\ such\ as\ ^\ and\ $.\r\n\r\n\ <p>\ Without\ anchoring\ bounds,\ the\ boundaries\ of\ this\r\n\ matcher's\ region\ will\ not\ match\ anchors\ such\ as\ ^\ and\ $.\r\n\r\n\ <p>\ By\ default,\ a\ matcher\ uses\ anchoring\ region\ boundaries.\r\n\r\n\ @param\ \ b\ a\ boolean\ indicating\ whether\ or\ not\ to\ use\ anchoring\ bounds.\r\n\ @return\ this\ matcher\r\n\ @see\ java.util.regex.Matcher\#hasAnchoringBounds\r\n\ @since\ 1.5\r\n
comment32.params=
comment32.target=java.lang.String\ toString()
comment32.text=\r\n\ <p>Returns\ the\ string\ representation\ of\ this\ matcher.\ The\r\n\ string\ representation\ of\ a\ <code>Matcher</code>\ contains\ information\r\n\ that\ may\ be\ useful\ for\ debugging.\ The\ exact\ format\ is\ unspecified.\r\n\r\n\ @return\ \ The\ string\ representation\ of\ this\ matcher\r\n\ @since\ 1.5\r\n
comment33.params=
comment33.target=boolean\ hitEnd()
comment33.text=\r\n\ <p>Returns\ true\ if\ the\ end\ of\ input\ was\ hit\ by\ the\ search\ engine\ in\r\n\ the\ last\ match\ operation\ performed\ by\ this\ matcher.\r\n\r\n\ <p>When\ this\ method\ returns\ true,\ then\ it\ is\ possible\ that\ more\ input\r\n\ would\ have\ changed\ the\ result\ of\ the\ last\ search.\r\n\r\n\ @return\ \ true\ iff\ the\ end\ of\ input\ was\ hit\ in\ the\ last\ match;\ false\r\n\ \ \ \ \ \ \ \ \ \ otherwise\r\n\ @since\ 1.5\r\n
comment34.params=
comment34.target=boolean\ requireEnd()
comment34.text=\r\n\ <p>Returns\ true\ if\ more\ input\ could\ change\ a\ positive\ match\ into\ a\r\n\ negative\ one.\r\n\r\n\ <p>If\ this\ method\ returns\ true,\ and\ a\ match\ was\ found,\ then\ more\r\n\ input\ could\ cause\ the\ match\ to\ be\ lost.\ If\ this\ method\ returns\ false\r\n\ and\ a\ match\ was\ found,\ then\ more\ input\ might\ change\ the\ match\ but\ the\r\n\ match\ won't\ be\ lost.\ If\ a\ match\ was\ not\ found,\ then\ requireEnd\ has\ no\r\n\ meaning.\r\n\r\n\ @return\ \ true\ iff\ more\ input\ could\ change\ a\ positive\ match\ into\ a\r\n\ \ \ \ \ \ \ \ \ \ negative\ one.\r\n\ @since\ 1.5\r\n
comment35.params=from
comment35.target=boolean\ search(int)
comment35.text=\r\n\ Initiates\ a\ search\ to\ find\ a\ Pattern\ within\ the\ given\ bounds.\r\n\ The\ groups\ are\ filled\ with\ default\ values\ and\ the\ match\ of\ the\ root\r\n\ of\ the\ state\ machine\ is\ called.\ The\ state\ machine\ will\ hold\ the\ state\r\n\ of\ the\ match\ as\ it\ proceeds\ in\ this\ matcher.\r\n\r\n\ Matcher.from\ is\ not\ set\ here,\ because\ it\ is\ the\ "hard"\ boundary\r\n\ of\ the\ start\ of\ the\ search\ which\ anchors\ will\ set\ to.\ The\ from\ param\r\n\ is\ the\ "soft"\ boundary\ of\ the\ start\ of\ the\ search,\ meaning\ that\ the\r\n\ regex\ tries\ to\ match\ at\ that\ index\ but\ ^\ won't\ match\ there.\ Subsequent\r\n\ calls\ to\ the\ search\ methods\ start\ at\ a\ new\ "soft"\ boundary\ which\ is\r\n\ the\ end\ of\ the\ previous\ match.\r\n
comment36.params=from\ anchor
comment36.target=boolean\ match(int,\ int)
comment36.text=\r\n\ Initiates\ a\ search\ for\ an\ anchored\ match\ to\ a\ Pattern\ within\ the\ given\r\n\ bounds.\ The\ groups\ are\ filled\ with\ default\ values\ and\ the\ match\ of\ the\r\n\ root\ of\ the\ state\ machine\ is\ called.\ The\ state\ machine\ will\ hold\ the\r\n\ state\ of\ the\ match\ as\ it\ proceeds\ in\ this\ matcher.\r\n
comment37.params=
comment37.target=int\ getTextLength()
comment37.text=\r\n\ Returns\ the\ end\ index\ of\ the\ text.\r\n\r\n\ @return\ the\ index\ after\ the\ last\ character\ in\ the\ text\r\n
comment38.params=beginIndex\ endIndex
comment38.target=java.lang.CharSequence\ getSubSequence(int,\ int)
comment38.text=\r\n\ Generates\ a\ String\ from\ this\ Matcher's\ input\ in\ the\ specified\ range.\r\n\r\n\ @param\ \ beginIndex\ \ \ the\ beginning\ index,\ inclusive\r\n\ @param\ \ endIndex\ \ \ \ \ the\ ending\ index,\ exclusive\r\n\ @return\ A\ String\ generated\ from\ this\ Matcher's\ input\r\n
comment39.params=i
comment39.target=char\ charAt(int)
comment39.text=\r\n\ Returns\ this\ Matcher's\ input\ character\ at\ index\ i.\r\n\r\n\ @return\ A\ char\ from\ the\ specified\ index\r\n
comment4.params=
comment4.target=java.util.regex.MatchResult\ toMatchResult()
comment4.text=\r\n\ Returns\ the\ match\ state\ of\ this\ matcher\ as\ a\ {@link\ MatchResult}.\r\n\ The\ result\ is\ unaffected\ by\ subsequent\ operations\ performed\ upon\ this\r\n\ matcher.\r\n\r\n\ @return\ \ a\ <code>MatchResult</code>\ with\ the\ state\ of\ this\ matcher\r\n\ @since\ 1.5\r\n
comment5.params=newPattern
comment5.target=java.util.regex.Matcher\ usePattern(java.util.regex.Pattern)
comment5.text=\r\n\ Changes\ the\ <tt>Pattern</tt>\ that\ this\ <tt>Matcher</tt>\ uses\ to\r\n\ find\ matches\ with.\r\n\r\n\ <p>\ This\ method\ causes\ this\ matcher\ to\ lose\ information\r\n\ about\ the\ groups\ of\ the\ last\ match\ that\ occurred.\ The\r\n\ matcher's\ position\ in\ the\ input\ is\ maintained\ and\ its\r\n\ last\ append\ position\ is\ unaffected.</p>\r\n\r\n\ @param\ \ newPattern\r\n\ \ \ \ \ \ \ \ \ The\ new\ pattern\ used\ by\ this\ matcher\r\n\ @return\ \ This\ matcher\r\n\ @throws\ \ IllegalArgumentException\r\n\ \ \ \ \ \ \ \ \ \ If\ newPattern\ is\ <tt>null</tt>\r\n\ @since\ 1.5\r\n
comment6.params=
comment6.target=java.util.regex.Matcher\ reset()
comment6.text=\r\n\ Resets\ this\ matcher.\r\n\r\n\ <p>\ Resetting\ a\ matcher\ discards\ all\ of\ its\ explicit\ state\ information\r\n\ and\ sets\ its\ append\ position\ to\ zero.\ The\ matcher's\ region\ is\ set\ to\ the\r\n\ default\ region,\ which\ is\ its\ entire\ character\ sequence.\ The\ anchoring\r\n\ and\ transparency\ of\ this\ matcher's\ region\ boundaries\ are\ unaffected.\r\n\r\n\ @return\ \ This\ matcher\r\n
comment7.params=input
comment7.target=java.util.regex.Matcher\ reset(java.lang.CharSequence)
comment7.text=\r\n\ Resets\ this\ matcher\ with\ a\ new\ input\ sequence.\r\n\r\n\ <p>\ Resetting\ a\ matcher\ discards\ all\ of\ its\ explicit\ state\ information\r\n\ and\ sets\ its\ append\ position\ to\ zero.\ \ The\ matcher's\ region\ is\ set\ to\r\n\ the\ default\ region,\ which\ is\ its\ entire\ character\ sequence.\ \ The\r\n\ anchoring\ and\ transparency\ of\ this\ matcher's\ region\ boundaries\ are\r\n\ unaffected.\r\n\r\n\ @param\ \ input\r\n\ \ \ \ \ \ \ \ \ The\ new\ input\ character\ sequence\r\n\r\n\ @return\ \ This\ matcher\r\n
comment8.params=
comment8.target=int\ start()
comment8.text=\r\n\ Returns\ the\ start\ index\ of\ the\ previous\ match.\ \ </p>\r\n\r\n\ @return\ \ The\ index\ of\ the\ first\ character\ matched\r\n\r\n\ @throws\ \ IllegalStateException\r\n\ \ \ \ \ \ \ \ \ \ If\ no\ match\ has\ yet\ been\ attempted,\r\n\ \ \ \ \ \ \ \ \ \ or\ if\ the\ previous\ match\ operation\ failed\r\n
comment9.params=group
comment9.target=int\ start(int)
comment9.text=\r\n\ Returns\ the\ start\ index\ of\ the\ subsequence\ captured\ by\ the\ given\ group\r\n\ during\ the\ previous\ match\ operation.\r\n\r\n\ <p>\ <a\ href\="Pattern.html\#cg">Capturing\ groups</a>\ are\ indexed\ from\ left\r\n\ to\ right,\ starting\ at\ one.\ \ Group\ zero\ denotes\ the\ entire\ pattern,\ so\r\n\ the\ expression\ <i>m.</i><tt>start(0)</tt>\ is\ equivalent\ to\r\n\ <i>m.</i><tt>start()</tt>.\ \ </p>\r\n\r\n\ @param\ \ group\r\n\ \ \ \ \ \ \ \ \ The\ index\ of\ a\ capturing\ group\ in\ this\ matcher's\ pattern\r\n\r\n\ @return\ \ The\ index\ of\ the\ first\ character\ captured\ by\ the\ group,\r\n\ \ \ \ \ \ \ \ \ \ or\ <tt>-1</tt>\ if\ the\ match\ was\ successful\ but\ the\ group\r\n\ \ \ \ \ \ \ \ \ \ itself\ did\ not\ match\ anything\r\n\r\n\ @throws\ \ IllegalStateException\r\n\ \ \ \ \ \ \ \ \ \ If\ no\ match\ has\ yet\ been\ attempted,\r\n\ \ \ \ \ \ \ \ \ \ or\ if\ the\ previous\ match\ operation\ failed\r\n\r\n\ @throws\ \ IndexOutOfBoundsException\r\n\ \ \ \ \ \ \ \ \ \ If\ there\ is\ no\ capturing\ group\ in\ the\ pattern\r\n\ \ \ \ \ \ \ \ \ \ with\ the\ given\ index\r\n
numComments=40
